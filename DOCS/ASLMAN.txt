/* 
 *  @script ASLMAN.txt                                                  
 * 
 *  @comment docs for ASL commands and usage                            
 *  @release Beryllium                                                  
 *  @vers 2.7 N Nitrogen [asl 6.4.54 C-Be-Xe]                           
 *  @date 07/30/2022 14:25:28                                           
 *  @cdate 1/1/2001 11:18:09 Boron [asl 6.3.61 C-Li-Pm]                 
 *  @author Mark Terry Boron [asl 6.3.61 C-Li-Pm]                       
 *  @Copyright Â© RootMeanSquare 2022 -->                               
 * 
 */ 
;//----------------<v_&_v>-------------------------//;                  

          

.de NP
.ft R
.sp 1
.ne 3
.ti +5
..

.de HE
.br
.sp
.lp
.ne 4
.ft B
..


.de BF
.in
.b
.ne 5
..

.de FD
.in 5
.in
.sp
.ne 3
..

.de EF
.in 5
.sp
.ne 2
..


.fo ''-%-''

.po 1i
.ll 6.5i
.nd
.ce 1
.ad l
.ls 1

.tp
.sp 2i
.(l C
ASL
.sp
A Script Language
.sp
.i
for use with the 
.sp
.b
Graphic and Signal Processing 
Package
.sp 2
.i
Mark Terry
.)l
.bp

.ce
SI 
.br
.ce 
VERSION 6.20 Ca
.sp
\(*td
.ft
.sp 2

.HE
Introduction

ASL is an interpreter, allowing expression evaluation, parameter
substitution function and procedure calling. 
It allows typing of variables, fixed length (int,float,double,cmplx,dcmplx,short,char)
and a varchar type (svar) for arbitarily long strings.

There is also a number type (pan) 
for arbitary precision calculations.
ASL arbitary precision calculations are done using radix 256 operations. 
Conversion to and from decimal to radix 256 is provided.

For manipulation of table data and spreadsheet input there is
a record type (RECORD_) that will read csv, or space delimited table/record data.

The purpose of ASL is to allow the user to build an application, 
which may be interactive, using the graphic display functions,
and the signal processing modules.
The application can be tailored for a specific need,
and may be easily changed or modified without requiring  recompilation.
Flow control is C like and  possible via an
"if {... } else if {...] else {...}" , for ( ; ; ; ) {  },
and "while ( ) { ... } " and do { } [while,until] () constructions. 
Nesting is allowed in constructions.


Display and control of signal processing is done by calling functions,
and signal processing modules.
These functions are listed together with a description of their effect 
and calling parameters in Appendix 1.
The utility 'sinfo' can be used to obtain the usage of script library functions.
e.g.
sinfo vgen
gives a description of a script library function that generates a vector.
----------------------------------------------------
vgen()
V=vgen(TYPE_,n,{init_val},{step})
generates a vector n values,of type (FLOAT_,INT_,SHORT_,CHAR_, CMPLX_ ...) initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.
For complex vectors each real imag pair is set to value and then the step is incremented.
-----------------------------------------------------


.HE 
SYNTAX

 The syntax is similar to the 'C' language.
 The priority of the operators is described
below. Use of parentheses can be used to force a particular parsing.
You may have multistatements on a line if they are separated by ';', otherwise a newline terminates
the statement (i.e. the ';' is not necessary for one statement per line).
The continutation character '\' is given at the end of the line, 
can be used to fit a long statement over several lines.

.i
statement:
.nf
	compound statement
	expression ;

        if (expression) statement

        if (expression) 
               statement

        if (expression) statement
        else statement


	if (expression) { 
	   statement ;
	   statement ;
	   ...
        }


	if ( expression) { 
	   statement ;
	   statement ;
	   ...
        }
	else if ( expression) { 
	   statement ;
	   ...
        }
	else {
	   statement ;
	   ...
        }


	for ( expression ; expression ; expression ) {
	   statement ;
	   statement ;
	   ...
	}


	while ( expression) {
	   statement ;
	   statement ;
	   ...
	}

        do {


        } while ( expression) ;


        do {


        } until (expression) ;


expression

An expression is made up of
	numbers   
		These are the digits ( 0 1 2 3 4 5 6 7 8 9 .) and the decimal point.

	variables 
	any alpha_numeric string of upto 7 characters beginning with alpha character.
	strings longer than 7 characters are allowed, but only the first 7 are used
	to identify the variable.

	operators 

	      *  multiplication
	      /  division
	      +  addition
	      -  subtraction
	      %  modulus operator gives the remainder of integer division
	      ^  exponentiation  e.g. 2^3 is 8
              =  equality
              += ( a += b equivalent to a = a + b)
              -=
              *=
              /=
              @+  string cat, or vector concatenation
              @/  string 'divide' (removes second argument string from first)
              ++ increment
              -- decrement

	relational operators
	      ==  equivalent to
	      <=  less than or equal to
	      >=  greater than or equal to
	      &&  and
	      ||  or
	      @=  string compare
              !=  not equal
	      
              AND_    and   &&
	      NAND_  nand |&
	      XOR_    xor   &|
	      OR_      or     ||
	      NOT_    not    !


	unary operators
		-  unary minus
	        !  negation

        bit operators
                &  bit and   BAND_
                |  bit or       BOR_
                >> bit shift right  RSHIFT_
                << bit shift left    LSHIFT_
                 ~ one's complement
                ^^  bit xor  BXOR_
	parentheses
	      ()

e.g
	A= 5 * 3 ;
	B = sin(sin(a+b) + cos(a-b));
	( A == 3)
	C = 3.0 * 2.5	;
are legal expressions. 
( sin and cos are the sine and cosine functions)
.b


.HE
RESERVED WORDS
 The following words are reserved and have functional meaning to the
interpreter
.i
.nf

   if
   else
   while
   do
   until
   for
   foreach
   switch
   case
   break
   continue
   return
   proc
   enum
   real
   float
   int
   short
   char
   double
   cmplx
   ascii
   static
   svar
   str
   varchar
   pan
   uint
   ushort
   uchar
   class

.b
.HE
METACHARACTERS

These characters have special meaning in a print format
	$
	\\
        %
if you want to use them in a print statement - precede with the escape character 
i.e \\$ or \\\\


.HE
DEFINES
.fi
 There are a number of builtin defines for ASL. The last character of a builtin define is '_".
 For example  colors WHITE_,BLACK_,RED_,ORANGE_,YELLOW_,GREEN_,BLUE_.
 also error conditions   EOF_ERROR_.
 see apppendix 3 for a listing.
 

.HE
FUNCTIONS
.fi
 Typically most of the math functions default to double precision. 
The names are case insensitive, so
 sin and Sin refer to the same function.
 Also underlines are filtered out so a function like cyclerow
can be referred to as cycleRow CycleRow or cycle_row. 
(note internal vars such as _clarg need the preceeding underline and 
internal defines need the following underline e.g. BLACK_, RED_ , ALWAYS_, GTE_ , ...)
For the math functions if the argument is a vector 
 then the result is a vector, so Cos(A) ,where A is a float vector , will deliver a vector of the cosines
 of the elements in input vector A. 


.HE
PROCEDURES
.fi
   ASL allows procedures to be defined and used.
The following example defines a procedure which multiplies 
two numbers and returns the result.
.nf

proc  mul_em(a,b)
{
  return ( a * b )
}

Use of this procedure would be as follows
z= mul_em(e,f)
<<" $z \n"

The type of the calling variable determines the return type.

variables may be declared locally within a procedure
e.g.

proc  sum_a(int H[], int n)
{
int i,s = 0
     for ( i = 0 ; i < n ; i++) {
      s += H[i]
     }
 return ( s )
}


proc foo(x,y) { z = x*y ; x *= y ; }

The procedure call mechanism can be by value foo(x,y) , or by reference  foo(&x,&y) 
the procedure can be called either way, (arrays should use reference only).
When by reference - the variable reference inside the procedure does not require
a (* dereference pointer operation as in C), it is accessed directly e.g. x *= y
will set the external calling variable value if it is a call be reference, otherwise if
call by value only a local copy of the variable is set.

Use -  foo (char x[], int y[])  -  foo (a,&b[10]), 
offset and bounds are passed - so shouldn't be able to overun within procedure.
If the types are not explicitly declared in the definition of the procedure,
the calling type sets the procedure type.

If the types are explicitly declared in the definition of the procedure,
then type conversion (when call by value) occurs where possible.
When by reference and the calling variable is unset then it is created with the procedure type.


The variables may also be declared as static where they retain their value
on a subsequent call of the procedure
e.g.
static int i,s = 0
or
static ascii k,j = 3/7

.HE
TYPES
.fi

The following types are available fixed length (int,float,double,short, char),
with unsigned integer types (uint,ushort,uchar)
and a varchar type (svar) for arbitarily long strings 
and also a number type (pan) for arbitary precision calculations.

Variables can declared explicitly 
e.g.
short j
int k
float f
double d
complex c
char c

and initialised 
e.g
float f = 3.2

.nf
Also declaration and automatic typing will occur if a variable is declared as a result
of an operation :
   i = 1
declares an 'int variable'
   f = 2.0 
declares a 'float variable'
   c= 'a'
declares a 'char variable'

f2 = i * f
declares a 'float variable' since the result is the highest type.

The string type svar variable will contain an ascii string of variable length.
Declaration is automatic if the variable is initialised to a string or the result of a string operation.

    e.g. s="a string"

This string variable can contain an arbitary number of records and each record can contain an
arbitary number of characters.
s[1] = "next record  of svar variable"

To obtain a substring from the svar variable use the SubStrfunction 

ns = s[1]->SubStr(0,4)
would copy "next" to the string variable ns.


Most Vector and Matrix operations return the type of the input variable but the result type
may be promoted to preserve precision. However, if the variable on the LHS of the equation was explicitly
declared then the result is converted to the 'receiving' type.  
Variables declared automatically (without a
type specification) will be converted to the result type.

.fi


.HE
Print Statements
.fi


=========================================================\n





.BF
print()
.(x
print
.)x 
.FD
print ()


 Expansion of variables to an ascii representation of their values will  take place within 
 a double quoted string when the variable name is prefixed with the $ operator.
 The print statements will also allow formating via the C % printf format mechanism.

e.g.
  x= 2.645
<<"$x  %7.2f$x  %4.0f$x %e$x \n"
would give
2.645000     2.64     3 2.645000e+00 

in addition %V will print out the variable name with a space prior to the formatted value of the variable.
For arrays a list format %(n,prerow,arraysep,postrow) specifer allows the vector 
to be printed out in rows of length n.
The number of elements, prerow, arraysep and postrow fields can be strings or variables.
These allow a vector to be printed in formatted rows   

e.g. <<"%(5,\t, ,\n)$Vec "

     0 1 2 3 4
     5 6 7 8 9
     10 11 12 13 14

You can also add a prefix and postfix string to the specifier.
Characters after the number and before the r are printed at the end of each row.
A prefix can be inserted by using a comma

e.g. <<"%(10,-->,\s,<--\n)$V\n"

 -->0 1 2 3 4<--
 -->5 6 7 8 9<--
 -->10 11 12 13 14<--

spaces and tabs can to be specified via \s, \t
<<"%(5,\s-->\s,,\s,\s<--\n)$V \n"

 --> 0 1 2 3 4 <--
 --> 5 6 7 8 9 <--
 --> 10 11 12 13 14 <--



/////////////////////////////////////////////////////////////////////////////
.HE
VECTORS ARRAYS and MATRICES
.fi
.sp 1
 Arrays can be declared as a fixed size 
.nf
float A[100]
or dynamically as
float C[]
or with an initial size which can be extended
float C[>100]

int   K[x]

space allocated to an array or vector can be released using 
the v_free function. All declared vectors are 'freed' at
the termination of a script.
The array C has been declared dynamically with an initial size of 100.
The array size will be expanded is required (within the limits of available memory).

(N.B. no space allowed between array name and square bracket)

Vectors can also be declared via a generator function vgen.

B= vgen(INT_,20)
and the initial value plus increment can be also be specified
B= vgen(INT_,20,0,1)

A= vgen(FLOAT_,100,0.0,0.25)


Vectors can be concatenated using the @+ operator
e.g.
C= A @+ B

C would be a float vector containing the concatenate 
elements of vectors A and B.
Matrices can also be concatenated if the number of columns are equal.
Rows of Matrices can be concatenated via the @< operator 
if the number of rows in the
two matrices are equal.




Array arithmetic can occur using *,+,-,/ operators.
if A is a float array then
 D= A * 3
would create an float array D of the same size as A and where each element of A is multiplied by 3.
 E = A + B
where A and B are both arrays,
would create an float array E of the same size as A and where each element of A
is added to corresponding element of B.
similarly 
 E = A * B


If we declare matrices

int A[2][3]
int B[3][2]

that is A has order 2x3 and B order 3x2
 and
 C = A * B
would give the matrix multiplication (number of columns of A equals number of rows of B, i.e. conformable)
and the dimensions of C would be C [2][2]
 whereas
 C = B * A
would result in the dimensions of C being C [3][3]
For matrix multiplication to occur the arrays must be of the order of two dimensions and conformable.
If a vector multiply is desired (each element multiplied by corresponding element) the number of dimensions
must be one. The Vec function will produce a vector - 

E = Vec(B) * Vec(A)
would give E as a vector with 6 elements.

The function Mdimn can be used to 'reorder' the dimensions
e.g.
 F= Mdimn(A,1,6)
gives a 'row vector' dimensions 1 row 6 columns
 F= Mdimn(A,6,1)
gives a 'column vector' dimensions 6 rows 1 column
this can also be done 'in place' using Redimn
e.g.
Redimn(A,6,1)
so A now has 6 rows and 1 column.

The Transpose of a 2D matrix is given by
 T = Transpose(B)    or T = Mtrp(B)

The inverse of square matrix can be found with Minverse (Minv) function.
I = Igen(9,1,1)
Redimn(I,3,3)
J= Minv(I)

and the determinant using Mdet
Dt = Mdet(I)


Operating on a range within the array

The syntax of the range is  [from: to : step]  - from is always included if within the parent
set. The to element is always included if the step coincides with that element.
A step of 1 is implied unless specified otherwise;

 C= E[2:5]
that is C becomes a 3 element vector with the referenced elements of E
 C= E[2:7]
specifies a range 2 to 7 inclusive

 C= E[2:8:2]
specifies a range beginning at 2  ending at 8 using a step of 2, so C has 4 elements (2,4,6,8 of E)
 C=E[:8:2]   begins at 0 
 C=E[1::2]  ends at the last step within the limit of the vector, using a step of 2.
 C=E[::3]   begins at 0 ends at the last step within the limit of the vector, using a step of 3.

The end of the array can also be specified as -1
  C = E[3:-1]
C contains elements of E from 3 to the last element of the array inclusive.

  C = E[-10:-1]

C contains the last ten elements of E of the array .



Operating on a subset of the array

A subset of an array can be specified in array operations
e.g.
  B[3,5,6] = 96
which would set elements 3 5 and 6 of vector B to the value 96
a range can also be specified using ; as an operator
  B[2:10:2] = 67
elements 2 to 10 in steps of 2 are set to 67


 C= E[D] 
where D is an integer array and its elements are using to select the subset of E
further 
 C= E[D[2:5]] 
 where D is also 'subscripted'.
 


 S= cos(T[1,2][2:4])
 would give a 2 dimensional array with array bounds[2][3].


 I[J] *= 2
 would select and double those elements of I that are indexed by integer array J.
 

 CHECK ---
//////////////////////////////
 Typically J would reference an element of I  only once, however J could contain
 many repeated references to a particular element of I. 
 If we wanted the operation
 to occur every time the I element was referenced then this is possible by using the list operator "'".
 e.g.
 I['J] += 1
 This can be useful if J was generated by a statistical process recording which elements of I are
 being referenced over time.
 Thus ['J] can be thought of as a list rather than a subset.
/////////////////////////


 You can use any function that delivers an Int type of array to subscript the
 array
 e.g.
 I[Sel(I,"<",0)] *= -1
 would work to turn the values  into Absolute values by using the Sel function to find the elements
 of I that are less than zero.


The function v_realloc may be used to reduce/increase the size of an array.

/////////////////////////////////////////////////////////////////////////////////////////
.HE
POINTERS
.fi
 A string variable can be used to 'point' to another variable by using $ symbol as
a derefence operator.
e.g.
//  use $ as variable pointer operator
int a_3 = 66

vn = "a_3"

k = $vn

$vn = 77

<<"%V$vn $k $a_3 \n"
// output is :-

vn a_3 k 66 a_3 77 

The string variable, 'vn' contains the name of the integer variable 'a_3'.
The action is that $vn is substituted as a_3. 
Since variables can be dynamically created the ability to create names
via variable expansion
can be used together with the $ operator create a set of variables.

e.g.
for (i = 0; i < 15; i++) {
  vn = "a_$i"
  $vn = i*2
  y = $vn
<<"%V$vn $y\n"
}


 A variable can be used as a pointer to array or another variable.
 The & operator is used to set the location of the referred variable or array
 to the pointer variable.

 e.g.
   p = &X[0]  

 The pointer may now be used as an argument to routines to enable a 'call by reference'


 e.g.
# --------------------------------------------------------------------------------------------

 proc foo(z[]) { <<"$cproc $z[0] $z[1] $z[2] \n";} // print the first three elements 
 float X[10+]  // declare float array initially with 10 elements 
 v_set(&X[0],0,1.0,20) // set first 20 values to 0,1,2,3 ... (array dynamically increased)

 foo(&X[1])  // print elements 1,2,3
 p = &X[0] // variable p points to array X
 foo(p)    // print elements 0,1,2

# --------------------------------------------------------------------------------------------

 The pointer variable can be dereferenced, but unlike C,  '$'  is used as
 the dereference operator.

 e.g.


 p = &X[2]
 q = $p // dereference of pointer p

 the value of q would be 2  (since at this point X[2] = 2.0).

 Another pointer can be created -

 e.g.
 newp = p

 The pointer newp also points at X[2].

 However these pointers are not directed at memory (as in C) but to variable space.
 The actual memory locations of the arrays may be changed but as long as they still
 exist the pointers to those variables ( which may be arrays) will still be valid.

 The pointer location and pointer type may be seen using the typeof function.
 e.g.
 <<" $p  $(typeof(p))  \n"
 would in this case print

    X[2]  float

 Note inside of the  double quotes used in the print statement the $ operator produces the
 value of a variable or the return value of a function.
 The 'value' of our pointer variable is the current location at which it is pointing.
 (in contrast with C language, this is not the memory location)
 If we want to print the contents of that location we can set a variable equal to
 the dereference the pointer and print that, or use a $$ sequence to print the
 desired contents.

 e.g.
 float v
  v= $p
 <<" $p  $X[2] $v $$p $$newp \n"

 would in this case print

   X[2]  2.000000 2.000000 2.000000 2.000000 
 and using the pointer variable to modify the contents of the referred array
 e.g.
 $p = -3.5
  <<" $p  $X[2] $v $$p $$newp \n"

 gives
 X[2]  -3.500000 2.000000 -3.500000 -3.500000 
 
 (the value of v not changed)

 Operations on the pointer variables, such ++, --, +=, -= can be carried out, and
 the interpreter will check for a valid location, otherwise an error will be
 reported and the pointer will not be moved. If the 'object/array' that is being pointed to
 is deleted then all pointers to the object will be made invalid, and subsequent
 attempts to use them will be reported as errors.


///////////////////////////////////////////////////////////////////////////////////

.HE
Object Orientated programming
 ASL supports classes with data members and member functions. 
Arrays of objects can be manipulated.

.HE
Threads, Mutexes and Semaphores

   Threading is implemented via wrappers around posix threads.


.HE
Sockets
   The graphic window manager usually communicates with asl clients via shared memory and pipes,
however it can use sockets for communication. The default port is 4779 and the server ip is supplied
on the command line to asl using -S address --- 
e.g.
asl -S 127.0.0.1  scriptname
would launch asl and it attempt to set up socket communication on the local machine (127.0.0.1) using
default port 4779 and run the script indicated on the command line.




.HE
USAGE
.fi
.sp 1
A number of example scripts are provided,
and the suggested approach for the new user would be to execute these,
and then modify them. 
Normally the script process is initiated and 
communicates with the window manager.
A number of scripts can be run simultaneously,
and a script can be initiated from within another script (see sp_script
command).
Most commands call for an operation on a window, this is referenced
by its window id (wid). An integer which is used in calls for graphic
commands e.g. Plot(wid,@line,x,y,X,Y).

A script can run totally independent of the window manager as long as no
graphic or window manager functions are called. For example,
.nf
asl -S  script_name
or 
asl script_name
.br
.fi
will execute the instructions is the script_file. 
Script files should a .g extension.


A debug stream for the graphic window manager
can be established by setting the debug level in
the devices menu. 
The stream is directed to the journal file
in the GASP directory,or if into a user GS directory if that exists.

Synchronization of display with the output of signal processing modules,
can be done by testing to see whether a particular file is present,
using the f_exist function ( also see the command function). 
All signal processing modules write a file called WORK/jobx (where x is the
job number),
at completion of processing. 

.nf

# example 1 .. use of "if" and "while"
A=1

B= 6 * A

if ( A  < B ) {
pr(A," is less       than ",B)
}
else {
pr("wrong"," ","answer")
}

while ( A <= B) {

A = A + 1
     
     if ( A > B) {
     print("last"," ","time",A)
     }
     else {
     print(A)
     }
}

.bp

Information on the signal processing modules can be obtained by typing
the 'info module_name' or alternatively using -h flag
e.g. info sg  (or sg -h)
returns

Usage: sg [-b -n -l -s -w -O -f -p -D  -i in_file -o out_file] 
-b	effective bandwidth     Hz
-n	fft_size	max 2048  
-l	frame_length    msecs  
-s	frame_shift	    msecs  
-w	win_length	sample_points  
-O	win_shift	sample_points  
-f	sampling frequency 	Hz  
-p	pre_emphasis	 	
-M	magnitude Spectrum else dB
N.B. Header information (if present) will override flag settings
sg :

The manual page for the module can be obtained by typing 'man_spm module_name'.
e.g. man_spm dfc 
gives the manual page for the data file conversion program.


.bp
.HE
.ce 1
APPENDIX 1 FUNCTIONS

{ } shows optional extra parameters - 
namecalling - names for all functions are case-insensitive and
underlines are removed before the function is referenced so for example

rotateMap
rotate_map

all access the same function - rotatemap

so in the script both styles of making functions names more readable are allowed.


=============================================================
.BF
asl()
.(x
asl
.)x 
.FD
asl
asl script
asl [options] script  arg1 arg2 ...
asl -i
asl -X script
options:
        -a   show ic code 
        -c   compile 
        -i   starts an interactive shell 
        -l   produce a listing file .lic of intermediate code
        -v   version
        -w   warn,debug
        -X   start the X-window graphic display
        -s   use following single quoted args as lines in script
                e.g. asl -s '<<" $(date()) \n"'
                would print today's date 
                asl -s 'a= 2 + 2; <<"$a\n";'
                would compute and print 2+2
.EF
///////////////////////////////////////////
.BF
syntax()
.(x
syntax
.)x 
.FD
The syntax is very similar to C.

	operators 

	      *  multiplication
	      /  division
	      +  addition
	      -  subtraction
	      %  modulus operator gives the remainder of integer division
	      ^  exponentiation  e.g. 2^3 is 8
              =  equality
              += ( a += b equivalent to a = a + b)
              -=
              *=
              /=
              @+  string cat, or vector concatenation
              @/  string 'divide' (removes second argument string from first)
              ++ increment
              -- decrement

	relational operators
	      ==  equivalent to
	      <=  less than or equal to
	      >=  greater than or equal to
	      &&  and
	      ||  or
	      @=  string compare
              !=  not equal

	unary operators
		-  unary minus
	        !  negation

        bit operators
                &  bit and
                |  bit or
                >> bit shift right
                << bit shift left
                 ~ one's complement
                '  bit xor
	parentheses
	      ()

.EF
/////////////////////////////// MEMORY ////////////////////////////////////////
=============================================================
.BF
dynamic
.(x
dynamic
.)x 
.FD
dynamic
Dynamic allocation vectors  can be declared as a fixed size 
.nf
float A[100]
or dynamically as
float C[]
or with an initial size which can be extended
float C[>100]
The dynamic version allows run time increase when needed.
The array can be also be resized by the resize function with the orignal contents
of the initial section preserved (e.g. a realloc).

V->setdynamic([onoff]) --- would set dynamic property ON/OFF
for resize, redimn operations dynamic property allows/forbids operation.
It is always possible to setdynamic porperty on for arrays.
(see isdynamic, setdynamic)
.EF
=============================================================
.BF
isdynamic
.(x
isdynamic
.)x 
.FD
V->isdynamic()
tests if vector is dynamic

.EF
=============================================================
.BF
setdynamic
.(x
setdynamic
.)x 
.FD
V->setdynamic([onoff])
if V is a vector sets dynamic (size) on or off - default no argument V is set to dynamic.
(see also  isdynamic, resize)
.EF
=============================================================




.BF
xic,compile()
.(x
xic
.)x 
.FD
xic(ONOFF)

  If xic argument is zero then statements following are not compiled.
  If xic argument is one then statements following are  compiled.

.EF
=============================================================
.BF
bscan()
.(x
bscan
.)x 
.FD
bscan
bscan(CV,swapbytes,&c,&s,&i,&f)
Uses the memory address of a supplied script variable
and converts values from char/uchar array into that address.
The conversion is made according to the type of the supplied variable.
A pointer to array with an index to provide an initial offset can be set
before conversions are made. 
The swapbytes parameter can be used to swap bytes before the conversion if set to 1.
e.g.
nb=bscan(&CV[7],0,&acharvar,&ashortvar,&anintvar,&afloatvar)

The function returns number of bytes processed by the conversions-
so it can be used as index to data array for further conversions.
.EF
=============================================================
.BF
fscanv()
.(x
fscanv
.)x 
.FD
fscanv(Fh,swapbytes,'fmt',&cv,&sv,&iv,&fv,&dv,&xv)
fscanv(A,swapbytes,'C4,S4,I4,F4,D4,X4',&cvec,&svec,&ivec,&fvec,&xvec)
reads from binary data file as directed by format string into variables.
C char, S short , I int, F float, D double, X cmplx
the number following the type designation allows 
mulitple item read into a supplied vector.
A single read C1 into a scalar is also allowed.
returns total number of bytes read.


.EF
=============================================================
.BF
fscanf ()
.(x
fscanf
.)x 
.FD
fscanf works similar to C function- except the fmt string should be between single quotes
e.g. 
fscanf(A,'%d %f %lf',&i,&f,&d)

where i is int, f float, d double.


.EF
=============================================================
.BF
fprintf()
.(x
fprintf
.)x 
.FD
fprintf(Fh,'fmt',var)
fprintf works similar to C function- except the fmt string should be between single quotes
e.g. 
fprintf(A,'n is %d\n',n)
if double quotes are used parameter expansion will occur and format characters like % would have
to 'escaped'
e.g.
fprintf(A,"n is \%d\\n",n)
.EF
=============================================================
.BF
printf()
.(x
printf
.)x 
.FD
printf('fmt',var)
printf works similar to C function- except the fmt string should be between single quotes
e.g. 
printf('n is %d\n',n)
if double quotes are used parameter expansion will occur and format characters like % would have
to 'escaped'
e.g.
printf("n is \%d\\n",n)


.EF
=============================================================
.BF
endian()
.(x
endian
.)x 
.FD
endian(),getbyteorder()
return the endianess of the  machine   1234 is lowest address is byte 0
4321 is lowest address is byte 4. Other architectures may give 3421.

.EF
=============================================================
.BF
memused()
.(x
memused
.)x 
.FD
memused()
After memory check has been turned (checkMemory(1)) memused cab be used to monitor
memory usage.
returns array  with following counts:
 [TotalSivMem,CountMemAlloc,TotalAlloced,TotalFreeded,CountMemBlocks,CountMemOps].

.EF
=============================================================
.BF
memaddr()
.(x
memaddr
.)x 
.FD
memaddr(&var)
returns the memory address for the memory of an asl script variable.
e.g.
int k
ma=memaddr(&k)
ma is at the internal memory storage for the script variable k 
int I[10]
ma=memaddr(&I[3])
ma is at the 4th element of the array memory storage for the script array variable I
.EF
=============================================================
.BF
memfill()
.(x
memfill
.)x 
.FD
memfill(ma,var)
writes to the  memory address the value of a variable
int k = 3
memfill(ma,k)
The value of 3 (sizeof (int) bytes) is written to memory address. 
Unless the memory address is valid and there is sufficent space then use of
this function will cause program errors. There is no type checking.

.EF
=============================================================
.BF
memvalue()
.(x
memvalue
.)x 
.FD
memvalue(ma,"type")

Access the memory address and obtain the value for a variable type
e.g.
val=memvalue(ma,"int")
would return the int value at the supplied memory address.
val=memvalue(ma+4,"int")
would return the next int value if the address "pointed to" an integer array.
.EF
/////////////////////////////// MATH ////////////////////////////////////////

Math functions (sin,cos,exp ...) are double precision 
(they access the C math library)


=============================================================
.BF
atan()
.(x
atan
.)x 
.FD
A=atan(a)
returns arctan where a is in radians, if a is an array,(matrix)
returns an array of computed arctans.
.EF
=============================================================
.BF
atan2()
.(x
atan2
.)x 
.FD
A=atan2(y,x)
returns principle value of arctan of y/x 
returns  value [-pi/2, pi/2]
.EF

=============================================================
.BF
Bubble()
.(x
Bubble
.)x 
.FD
Bubble(A)
Performs an in place bubble sort of array 
.EF

=============================================================
.BF
Sort()
.(x
Sort
.)x 
.FD
Sort(A)
Performs a sort of an array vector, default is to use quicksort
A->Sort() - performs an inplace sort (low to high)  of vector
Use A->reverse() to then obtain results in high to low order.
Sort(A)
.EF
=============================================================
.BF
Isort()
.(x
Isort
.)x 
.FD
P=Isort(A)
Performs sort of an array vector returns a vector of the  positions
of the elements in low to high order.
.EF

=============================================================
.BF
msortrow()
.(x
msortrow
.)x 
.FD
P=msortRow(M,row)

sorts a matrix via a selected row -
the selected row is sorted via ascending value 
and the resulting column positions are used to rearrange all columns.


.EF
=============================================================
.BF
Median()
.(x
Median
.)x 
.FD
Median(A)
returns median value of array-- the array size is obtained from the array variable
If A is a matrix - a column vector of the medians for each row is returned.

=============================================================
.BF
cos()
.(x
cos
.)x 
.FD
Cos(a)
returns Cosine where a is in radians, if a is an array,(matrix)
returns an array of computed cosines

.EF
=============================================================
.BF
rad2deg(a)()
.(x
rad2deg
.)x 
.FD
rad2deg(a)
returns degrees from radians
.EF
=============================================================
.BF
deg2rad(a)()
.(x
deg2rad
.)x 
.FD
deg2rad(a)
returns radians from degrees 

.EF
=============================================================
.BF
Cspline()
.(x
Cspline
.)x 
.FD
Cspline(X,Y,n,xs,ys,m)
 Fits a cubic spline function to the n values specified in the X and Y arrays for the 
 m desired x values in the xs array. 
 The spline fit results are placed in the ys array. 
.EF
=============================================================
.BF
_clarg,_clargs()
.(x
_clarg
.)x 
.FD
_clarg[1]
 _clarg  is an internal array containing the original command line arguments.
 _argv is also a name for the same internal array

 internal args have a '_' preceeding the name to distinguish from user script variables.

  na = Caz(_clarg) 
  na is the number of command line arguments,   
  na = argc() --- also gives number of command line args

  wa = _clarg[1]
  or
  wa = _argv[1]

  wa contains the first argument.
<<"$_clarg \n"
  will print the list of command line args
  use atoi(), atof() to make numeric conversions where appropriate 
.EF
=============================================================
.BF
testargs()
.(x
testargs
.)x 
.FD
Arglist=testargs(a1,a2,...)
use for debug -- function will print to an svar variable
the description and value (where possible) of the argument.
the statement
<<"%(1,,,\n)$Arglist\n"
would print those one per line to stdout.
(see printargs() )
.EF
=============================================================
.BF
printargs()
.(x
printargs
.)x 
.FD
printargs(a1,a2,...)
use for debug -- function will print 
the description and value (where possible) of the argument.
.EF
=============================================================
.BF
fprintargs()
.(x
fprintargs
.)x 
.FD
fprintargs(Fh,a1,a2,...)
use for debug -- function will print to file using file handle (see ofile) 
the description and value (where possible) of the argument.
.EF
=============================================================
.BF
isargnumber()
.(x
isargnumber
.)x 
.FD
isargnumber(_clarg[1]) 
would return 1 if argument is a number
.EF
=============================================================
.BF
isadigit()
.(x
isadigit
.)x 
.FD
isadigit(a_str) 
would return 1 if first char of string a_str is a digit (a_str can be single char) 
.EF

=============================================================
.BF
isanumber()
.(x
isanumber
.)x 
.FD
isanumber( a_str) 
would return > 0  if argument is a number string 
1 integer
2 real
.EF

=============================================================
.BF
internal vars()
.(x
internal vars
.)x 
.FD
There are a number of internal vars that can be accessed.
_clarg -- vector of command line args
_proc  -- current procedure (or main)
_script -- script name
_include -- current include file/block 

.EF

/////////////////////////////   STAT /////////////////////////////////////

=============================================================
.BF
Lip()
.(x
Lip
.)x 
.FD
Lip(X,Y,n,x,y,m)
linear interpolation to the n values in the X & Y array for the 
m desired values in the x array. 
Results in the y array. 

.EF
=============================================================
.BF
polyncof()
.(x
polyncof
.)x 
.FD
cof = polyncof(X,Y,n)
polynomical coefficient calculation  to the n values in the X & Y array  
Results are returned as n values in a coefficient array. 

.EF
=============================================================
.BF
polygen()
.(x
polygen
.)x 
.FD
Y = polygen(X,cof,nc)
polynomical coefficients used on  X  array  
to generate a Y array of the same size of the X array. nc are the mumber of coefficients used
e.g. computes similar to
 Y = cof[0] + X[i] * (cof[1] +  X[i] * ( cof[2] + X[i] * (cof[3] + X[i] * cof[4])))
for 5 coefficients
.EF
=============================================================
.BF
ptinpoly()
.(x
ptinpoly
.)x 
.FD
inout = ptinpoly(poly2d,nverts, x,y )
Is the point (x,y) in the closed polygon (polygon array of points, number of verts, x,y)
return 1 if point is in , 0 if not.
.EF
=============================================================



.BF
Mlip()
.(x
MLip
.)x 
.FD
MLip(NewX,M,{X})
linear interpolation using the  X array as the x values for the y values 
in each columnn for individual rows of the matrix, The interpolation is
to desired values in the NewX array. 
Results in the returned in new matrix where columns equals number of values in NewX
MLip(NewX,M)
In this form - the first row of the matrix is treated as the X vector and the NewX becomes the
new first row after the interpolation has taken place.
.EF


=============================================================
.BF
Vsmooth()
.(x
Vsmooth
.)x 
.FD
Vsmooth(V,w_len)
The values in the vector are smoothed (average) by window of length w_len. 
.EF
=============================================================


.BF
Msmooth()
.(x
Msmooth
.)x 
.FD
Msmooth(M,w_len)
The values in each row are smoothed (average) by window of length w_len. 
.EF
=============================================================
.BF
MColsmooth()
.(x
MColsmooth
.)x 
.FD
MColsmooth(M,w_len)
The values in each column are smoothed (average) by window of length w_len. 
.EF

=============================================================
.BF
Lfit()
.(x
Lfit
.)x 
.FD
fp=Lfit(X,Y,[n])
 Linear fit of values in X and Y array. The fit is returned as an array
fp[0] is the constant c and fp[1] is the slope parameter m so a new value  y = mx + c.
e.g.
fp=Lfit(X,Y,[n])
The first n values of X,Y vectors are linearly fitted
- constant and slope parameters return in vector fp
Use the size of smallext array or specified size using [n].
.EF

=============================================================
.BF
rpc()
.(x
rpc
.)x 
.FD
fp=rpc(X,Y)
Computes correlation coefficient between two functions.
returns into return array the slope, regression , and  principle component variances
.EF
/////////////////////////////// AUDIO ///////////////////////////////////////

=============================================================
.BF
createsignalbuffer()
.(x
createsignalbuffer
.)x 
.FD
sbn=createsignalbuffer

  creates a signal buffer for audio applications. Function returns a buffer handle.
User can then read a vox file into the buffer - readsignal(sbn, vox_file_name)
.EF

=============================================================
.BF
addsignal()
.(x
addsignal
.)x 
.FD
addsignal(wid,x,sample_number_1{, sample_number_2})
 
adds x to the signal present in the signal buffer associated with window wid,
from sample_number_1 to sample_number_2. 

add_signal(wid,x,0) will operate on  the entire buffer.
add_signal(wid,x,1) will operate on  the select region buffer.
add_signal(wid,x,s1,s2) will operate on  the region s1 to s2 inclusive.
.EF

=============================================================
.BF
CopySR()
.(x
CopySR
.)x 
.FD
CopySR(wid)

The select region of the buffer  associated with 
window wid is copied to the cut/paste buffer.
.EF

=============================================================
.BF
cutsr()
.(x
cutsr
.)x 
.FD
cutsr(wid)

The select region of the buffer associated with window wid 
is cut into the cut/paste buffer.
The function returns the  new reduced buffer size in samples.
.EF

=============================================================




=============================================================
.BF
drawSignal()
.(x
drawSignal
.)x 
.FD
drawSignal(wo_id, sbn, {sample_number_1, {sample_number_2} })
 
draws the signal present in the signal buffer referenced by sbn  associated with window object wo_id,
from sample_number_1 to sample_number_2. 
e.g
drawsignal(wo_id,sbn,s1,s2) will draw the signal inclusive between sample s1 and sample s2.
drawsignal(wid, sbn) will draw the signal using current window coordinates.
drawsignal(wid,sbn,0) will draw the entire buffer.
drawsignal(wid,sbn,1) will draw the select region.
drawsignal(wid,sbn,2) will draw the signal using the previous window coordinates.
.EF


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

////////////////////////////// PLOT ////////////////////////////////////////

=============================================================
.BF
axis()
.(x
axis
.)x 
.FD
axis(wid,axis,s,S,ds,tl,p)

draws an axis line at scale value p of the opposing axis and
places tick_marks at interval ds starting at value s and finishing at S.

horizontal axis 1
vertical   axis 2
tick marks of length tl where tl is a fraction of the
drawing area i.e. tl = 1.0 will be a grid line
tl = 0.05 will give a "normal size tick mark"

.EF
=============================================================
.BF
axnum()
.(x
axnum
.)x 
.FD
axnum(woid,axis,start_value,stop_value,incr_value,offset,format,[minor_incr])
for the window object woid label the specified axis from start_value to stop value 
in increments of incr_value, positioned from the axis by (offset * font_size), using number
format specified - format specification should be quoted. If offset is negative the label
strings are positioned inside of the graph (clip) area.
Optionally a minor increment tick interval can be set.

bottom axis 1
left   axis 2
top    axis 3
right  axis 4
e.g.
axnum(woid,1,0.0,2.0,0.1,3.0,"3.1f")
or
axnum(woid,1)
labels the axis via default settings.
.EF

=============================================================
.BF
plot()
.(x
Plot
.)x 
.FD
plot(wid,@line,x,y,X,Y,"color")
Most plotting of graphic 'objects' lines,points, polygons, shapes , symbols etc
are done with the following syntax
plot command with the following arguments

arg1 a drawing area id  typically the window object id returned when creating a window or drawing area 
     within a window 
arg2 graphic object line,point,polygon the argument can be as "line" or @line
then following arguments are parameter that define the position, shape , color graphic context.
arg3 x
arg4 y
arg5 "red"

e.g.
plot(wid,@point,x,y,"red")
plot(wid,@line,x,y,X,Y,BLUE)   -- WHITE_,BLACK_,RED_,ORANGE_,YELLOW_,GREEN_,BLUE_
are known defines.

The @argument starts an argument list and there can be multiple argument lists for one plot statement.
Optional arguments are permissible since the next @argument ( a tag argument) starts a new list.
e.g.
plot(wid,@box,x,y,X,Y,BLUE,@line,x,y,X,Y,RED)  - which plots a blue outline box with a red diagonal line

.EF
=============================================================
.BF
@point()
.(x
point
.)x 
.FD
plot(wid,@point,x,y,{hue})
plots point at x,y real coors position in window wid.
By default in current window pen color.
If hue -1 a dark move is made.
plot(wid,@points,RPTS)
RPTS is a float matrix of nrows of 2 cols where each row is x,y values,
the point is drawn at x,y value using current window foreground hue.

.EF
=============================================================
.BF
Line()
.(x
line
.)x 
.FD
Plot(wid,@line,{x,y},X,Y,{hue})
plots line from x,y real coors position to X,Y in current window.
if x and y are not specified then the line is plotted from the
current pen position to X,Y.
If hue is set to -1 a dark move is made.

.EF
=============================================================
.BF
Lines()
.(x
lines
.)x 
.FD
Plot(wid,@lines,RL)
RL is a float matrix of nrows of 4 cols where each row is x,y,X,Y values per line.

Plot(wid,@lines,RL)
RL is a float matrix of nrows of 2 cols where each row is x,y values,
the line is drawn between current x,y and the next x,y pair

.EF
=============================================================
.BF
LineTo()
.(x
LineTo
.)x 
.FD
Plot(wid,@lineto,{x,y},{hue},{GC})
plots line from last position to x,y real coors position current window drawing
area.
If hue is set to -1 a dark move is made.
GC parameter is either "xor" or "copy" - default is copy. 
If xor graphic context mode is chosen then there isa xor operation with underlying pixels
and subsequent draw with xor will erase the line and restores underlying pixels.

Plot(wid,@linesto,RL,{hue},{GC})
RL is a float matrix of nrows of 2 cols where each row is x,y values per line,
the first x,y is a dark move to and then a line is drawn to the next x,y pair and so on.

.EF
=============================================================
.BF
Circle()
.(x
Circle
.)x 
.FD
plot({wid},@circle,x,y,r,{hue},{fill})

plots circle from x,y real coors position radius r
in current window.
If fill set to 1 ,default 0, then a filled circle is drawn.
.EF
=============================================================
.BF
Ellipse()
.(x
Ellipse
.)x 
.FD
plot({wid},@ellipse,x,y,a,b,{hue})
plots ellipse from x,y real coors position major a, minor b,
axis in current window.
.EF
=============================================================
.BF
FillCircle()
.(x
FillCircle
.)x 
.FD
fillCircle (Pic, x, y, radius, val1, val2, mode)
For a supplied 2D array  and x, y  offset into the grid and supplied radius
fill pixels with graduated value from val1 at outer edge to
val2 at center. If mode is 0 the value overwrites the existing,
mode 1 uses a maxof substitution, mode = 2 the values is added to the existing.
(see fillEllipse)
.EF
=============================================================
.BF
FillEllipse()
.(x
FillEllipse
.)x 
.FD
fillEllipse(Pic, x, y, minor_radius,major_radius, val1, val2, mode)
For a supplied 2D array  and x, y  offset into the grid and supplied minor and major radius
fill pixels with graduated value from val1 at outer edge to
val2 at center. If mode is 0 the value overwrites the existing,
mode 1 uses a maxof substitution, mode = 2 the values is added to the existing.
(see fillCircle)


.EF
=============================================================
.BF
Box()
.(x
Box
.)x 
.FD
Plot(wid,@box,x,y,X,Y,{hue,fill})

plots box from x,y real coors position to X,Y in current window.
box color set to hue. Will fill box area if fill set to 1.
the second form Plot(wid,@box,x,y,X,Y,{hue,fill})
is a general way of calling plot function for a graph type, e.g. line,point, box, symbol
the type is prefixed by @ sign ( it can also be used as between quotes e.g. "box") the following parameters
are position, [size], color, angle and fill.

.EF
=============================================================
.BF
Wbox()
.(x
Wbox
.)x 
.FD
Plot(wid,@wbox,ix,iy,iX,iY,{hue,fill,origin})

plots box specified as pixel offset  from specified origin  (1 window x,y : 2 basewo x,t 3 :basewo CR x,y)
box color set to hue. Will fill box area if fill set to 1.
e.g. plot(vp,@wbox,10,10, 90, 90, RED_, 1)
plots a red filled box at offset 10,10  80 pixel square rectangle from  a windows Left bottom corner.
the origin can also be  the basewo position or the clip region position of the base wo.

.EF
=============================================================
.BF
ScrnBox()
.(x
ScrnBox
.)x 
.FD
Scrnbox(x,y,X,Y,{hue,fill})

plots box on screen with wcreen coors (int)  x,y X,Y in specified hue and either outline or filled. 
.EF
=============================================================

.BF
symbol()
.(x
symbol
.)x 
.FD
plot({wid},@symbol,x,y, symbol_number,symbol_size,hue,{fill, ang, gcontext, hsx,hsy})
plots symbol at x,y position in current window.
Size is a percentage of window size.
Shape and hue can be indicated via number or word
(diamond,5  red,1)
The symbol can be rotated by ang.
The gcontext graphic context can be set to XOR ("xor","copy","nand") so that subsequent plot of the symbol restores
the original pixels and the symbol can be used as a cursor.

The "center" of the symbol (hsx =0.0,hsy = 0.0) can be shifted by hsx,hsy
parameters as fractions of symbol size.
If fill is set to 1 a solid symbol is drawn.
.nf
Left_triangle    0
Triangle    1
Inverted_triangle    2
Right_triangle    3
Inverted_Cross  4
Diamond  5
Square  6
Star  7
Circle    8
Star5    9
Cross  10
Plane  11
.fi
.EF
=============================================================
.BF
symbols()
.(x
symbols
.)x 
.FD
plot({wid},@symbols,Pts, symbol_number,symbol_size,hue,{fill, ang, hsx,hsy})
plots array of symbols at x,y position from Pts array (x,y) in current window.
Size is a percentage of window size.
Shape and hue can be indicated via number or word ( "diamond" or 5,  "red" or 1)
The symbol can be rotated by angle
The "center" of the symbol (hsx =0.0,hsy = 0.0) can be shifted by hsx,hsy
parameters as fractions of symbol size.
If fill is set to 1 a solid symbol is drawn.

.EF
=============================================================
.BF
wosymbol()
.(x
wosymbol
.)x 
.FD
plot({wid},@wosymbol,symbol_number,symbol_size,hue,{ang,fill,hsx,hsy})
plots symbol in middle of window object.
Size is a percentage of window size.
Shape and hue can be indicated via number or word
(diamond,5  red,1)
The symbol can be rotated by ang.
The "center" of the symbol (hsx =0.0,hsy = 0.0) can be shifted by hsx,hsy
parameters as fractions of symbol size.
If fill is set to 1 a solid symbol is drawn.
.nf
Left_triangle    0
Triangle    1
Inverted_triangle    2
Right_triangle    3
Inverted_Cross  4
Diamond  5
Square  6
Star  7
Circle    8
Star5    9
Cross  10
Plane  11
.fi

.EF
=============================================================
.BF
plot_xy()
.(x
plotxy
.)x 
.FD
plot_xy(wid,file_name, x_channel_number, y_channel_number, 
line_type, symbol_number, symbol_size, auto_scale)
 
plots the specified x parameter  (channel) out of named file in the current window
against the specified y parameter.
If symbol_number is zero no symbols ar plotted, otherwise the chosen symbol is 
plotted at each x,y point. If line_type is zero , no connecting line between (x,y)
points is plotted. Symbol size is a percentage of the clip region size.
If auto_scale equals -1 the current window scales are used.
If auto_scale equals 1 the file is scanned to set the window scales, otherwise the header
information is used.
e.g.
plot_xy(w1,df_name,0,1,1,0,5,1)


.EF
=============================================================
.BF
plotPixRect()
.(x
plotPixRect
.)x 
.FD
plotPixRect(wid, PR, {Mapi, x,y, dir, pdir} )
The pixels to be plotted are represented in a matrix PR (type uchar).
By default they are plotted as rows starting from the top lefthand corner;
An offset x,y pixels from the top lefthand corner can be specified in the  
the clip region ofwindow object wid. 
The value of each uchar is used added to the base index (Mapi) to give  the index to the 
current color map, and this  determines the color of the specified pixel.

If the parameter dir is set to one then succeeding rows are plotted upwards from initial position.
That is the orginal y position pixel is either decremented (dir =0) or incremented (dir =1).
The parameter dir can control the successive positions of the x position
 (dir =2) x is incremented, (dir =3) x is decremented.

The parameter pdir controls the direction each individual strip (row) is plotted 
(pdir = 0) left to right
(pdir = 1) upwards
(pdir = -1) downwards
(pdir = 2) right to left


.EF
=============================================================
.BF
setgc()
.(x
setgc
.)x 
.FD
setgc("XOR")
graphic_context for drawing - the mode can be XOR,COPY

.EF
/////////////////////////////////// 3D PLOT ////////////////////////////////////////
=============================================================
.BF
makeObject()
.(x
makeObject
.)x 
.FD
obid1 = MakeObject(TYPE,{M[][]},x,y,z,xs,ys,zs,os,{rx,ry,rz},{fill})

obid1 = MakeObject("CUBE",-200,0,50,1,1,1,50,{1})
makes an object -- types known cube,pyramid,grid, matrix
following parameters
if it is a MATRIX type then a 2d matrix
then
position x,y,z
scale for x,ys,zs sides of object
overall scale os
rotation rx,ry,rz  -- default is zero

fill -- each region of object is filled, otherwise it is a wireframe object.
return is an object handle -- the object handle can be used to move, rotate the
object from the script
e.g.
RotateObject(obid1,-90,0,0)

MakeObject can be supplied a matrix (n rows, m cols) and those values are used the y values
of a uniform grid.  
e.g.
obid2 = MakeObject("MATRIX",MX,-150,0,10,4,0.2,4,0.5,0)
.EF
=============================================================
.BF
rotateObject()
.(x
rotateObject
.)x 
.FD
rotateObject(obid1, ang_X, ang_Y, ang_Z)

Object is rotated around the X, Y and Z axis by ang_X, ang_Y and ang_Z degrees.
.EF


.BF
rotate()
.(x
rotate
.)x 
.FD
rotate(vec, dir, nsteps)

Vec->rotate(dir,nsteps)

Vector is rotated in direction (1 forward , -1 backward) for nsteps


.EF


//////////////////////////////////  DATA-IO ///////////////////////////////////////



=============================================================
.BF
bunpack()
.(x
bunpack
.)x 
.FD
bunpack(CV,[swapbytes],"C,S,S,I,F,F,",a,b,c,d,e,f)
 will use a comma delimited format string  e.g. C,S,S,I,F,F to unpack byte-array into
 list of variables or array making conversions/as necessary
 i.e. b could be a short variable and c could be an integer variable
 the format ">" would shift past a byte prior to next conversion.
 the format "<" would backup a byte prior to next conversion.
 each format character maybe preceeded by a number e.g. 5S in which case
 five shorts would be unpacked into a vector variable.
.EF
=============================================================
.BF
packb()
.(x
packb
.)x 
.FD
nc=packb (UCV,[swapbytes],"I,F,UC,C,L",i,f,uc,c,l)

will take a uchar vec and format string "I,F,UC,C,L"
and following args/constants convert according to the format specifier
and then pack them into the uchar vector according to
sizeof of the format specifier
if optional second argument is 1, then pairs of bytes are swapped.
The number of bytes used is returned.

Elements of an array can be packed by following format identifier
with a number.
e.g.
Ivec= vgen(INT_,10,0,1)
packb (UCV,"I5,",Ivec)

would place the first 5 elements of the Ivec into UCV

The size of UCV must be large enough to hold specified elements.

The UCV can be enlarged via Realloc.

.EF
=============================================================
.BF
unpackb()
.(x
unpackb
.)x 
.FD
nc=unpackb (UCV,[swapbytes],"I,F,UC,C,L",&i,&f,&uc,&c,&l)

extracts types from a char array - controlled by a format string (see packb)
also the values can be read out into an array
e.g.
nc=unpackb (UCV,[swapbytes],"I5",ivec)
 in this example 5 integers are read out and stored into the ivec (INT) array

 these functions (see packb) allow a variable number of extractions and storage  governed
by the format string and supplied variables.

============================================================
.BF
timeconvert()
.(x
timeconvert
.)x 
.FD
timeconvert(timestr,['fmt'])
returns time in secs (float) after converting a time string HH:MM:SS:ss
an optional format string can be supplied to convert the time string 
so  different formats can be processed e.g. HH/MM/SS 
timeconvert(timestr,'%d/%d/%f')

timeconvert(timestr,'%d:%d:%f')
.EF
/////////////////////////////// VECTORS/MATRICES ///////////////////////////////////////

=============================================================
.BF
Cab()
.(x
Cab
.)x
.FD
Cab(M)
Check array bounds returns a vector of the dimensions of M

int M[4][5]
bd=Cab(M)
bd[0] is 4, bd[1] is 5.

.EF

=============================================================
.BF
Cnd,getND()
.(x
Cnd
.)x
.FD
Cnd(A)
returns number of dimensions
if A is a scalar function returns 0
.EF
=============================================================
.BF
Cmp(),CmpArray()
.(x
Cmp
.)x 
.FD
Cmp(A,B,condition,[1])
compares 2 arrays  of same order using "<,>,==,,!=,>=,<=" operations
    delivers an integer array which contains indices - where the
    operation was TRUE - else first element is -1 for no valid comparison
optionally delivers integer array where elements are 0 or 1 
depending on TRUE/FALSE of element comparison
e.g.
I=Cmp(A,B,"<=")
I=Cmp(A[::2],B[0::2],">")
I=Cmp(A,B,"!=",1)
.EF
=============================================================
.BF
cmpsetv()
.(x
cmpsetv
.)x 
.FD
cmpsetv(vec, op,cmp_value, set_value)
compares and sets elements of a vector to set_value if compare operator (">,>=,<,<=,==") 
on an element with the cmp_value is true.
cmpsetv(vec,">",1,1)
will limit vector values to 1
 Another operation may done sequentially e.g
cmpsetv(vec,">",10,10,"<",-10,-10)  
would limit vector between range -10,10.
.EF
=============================================================
.BF
Set(),set ~ sets values in a vector or a scalar()
.(x
set
.)x 
.FD
V->set(value)
V[3]->set(value)
V[1:20:2]->set(value_vec)
V[1:20:2]->set(value_vec,incr)

sets elements of a variable to supplied value vector.
if the variable is a scalar then just its value is set.
Can be used to set a specified element of the variable array,
or a subrange or the entire array.
The initial vaue can be incremented at each set step to create a series.

.EF
=============================================================
.BF
Caz,Csz ~ check size, check array size()
.(x
Caz
.)x 
.FD

Caz(A) 
returns current size (number of elements) where A is an  vector matrix

Caz(&i) 
would return 0  when i is a scalar.


Caz(A[1:9:2]) returns 5 
the subscripted size 
assuming A has at least 10 elements.

.EF
=============================================================
.BF
findVal()
.(x
findVal
.)x 
.FD

rvec=findVal(V,value,sindex,direction,[all=0],[">,>=,==,<,<="])
rvec=findVal(V,value,sindex,direction,[all=0],[GT_,GTE_,EQU_,LT_,LTE_])
rvec=V->findVal(value,sindex,direction)

searches vector V for a value comparison (default ==]
either for the first location (default) or for all locations.
A vector (int) is returned  and contains the index(es) 
where the supplied value and  element value comparison is true.
If no comparison is true , then returned vector is  of size 1 
and the first element of that vector is -1.

sindex (default 0) is starting index for search - direction 1 is towards higher elements,
direction -1 is towards lower elements,
sindex can be used to index from the back of the array -1  is last element in vector.
Optionally a condition can be supplied and
then the test will be where the test value compared to array element value.
If the comparison is true then the element of the vector rvec 
is set to array index where the comparison is true.

If the all parameter is set to 1
then a vector of all array indices where the comparison is true
is returned.

If there are no true comparisons the first element of return vector is -1.
.EF

///////////////////////////////////// IO //////////////////////////////////////////////

=============================================================
.BF
fread()
.(x
fread
.)x 
.FD
fread
fread(var_ptr, n_bytes, n_items, file_handle)

float f
A=ofr("data.bin")

nir = fread(&f,4,1,A)

would read a float from the file. 
It returns number of items read -- short count or zero when end of file is reached.

Use A=ofr(fname) - to get a file handle for reading or use 0 for standard in.
.EF

=============================================================
.BF
fwrite()
.(x
fwrite
.)x 
.FD
fwrite
fwrite(var_ptr, n_bytes, n_items, file_handle)

float f = 79
A=ofw("data.bin")

nir = fwrite(&f,4,1,A)

would write a float to the file

Use A=ofw(fname) - to get a file handle for writing or 1 for standard out.


.EF
=============================================================
.BF
printf()
.(x
printf
.)x 
.FD
printf ()
The printf  format is like the C version except that the format string needs to be single quoted 
otherwise the double quoted string is processed for parameter expansion and % is a special character
that looks to format an immediate neighboring variable. Double quotes can be used but the % needs
to have escape character.

e.g.
float f = 67
int i = 80
printf('this is a float %f and this is an int %d\n',f,i);
printf("this is a float \%f and this is an int \%d\n",f,i);
the alternative print format available is

<<"this is a float %f$f and this is an int %d$i\n"
.EF


=============================================================
.BF
CountWords()
.(x
CountWords
.)x
.FD
wcv=CountWords(A,{delimiter})
counts the lines, words and characters in file pointed to by file handle A
returns these to a vector
optionally can specify a delimiter  default is whitespace
.EF
=============================================================
.BF
command()
.(x
command
.)x
.FD
command(p1,p2,p3...)
issues the Unix command line
p1 p2 p3 
returns the shell exit number. 
Used mostly for remote shells since it will wait until job is finished
before moving to the next statement in the script. If the last argument is
an '&' , then the job is placed in background and the next script statement
is executed. Use this function to issue UNIX commands like rm, cp, cat, etc.
(see gs_job).
e.g. command("ls *.wav > vox_list")
or
command("ls ",the_files," > file_list")
Alternatively the following syntax(es) can be used

S= !!"ls -l *.vox"

The sivar variable contains the directory listing - 
and the following command would print the list to stdout.
!!"$S\n"

the parent will wait till all output is returned

pid = !!&"aprogram arg1 arg2"

would fork and execute aprogram and return the program's pid if succesful
the parent program continues


fptindex = !!|"aprogram *.vox"

issues a popen command and returns a file handle from which to read
the program continues and the popen output can be read as desired.
.EF





=============================================================
.BF
closefile,cf()
.(x
closefile
.)x
.FD
closefile(A)
closes file previously opened via A=o_file(file_name,"r+")
Can close a list
e.g
cf(A,B,C)
.EF
////////////////////////////////// WINDOWS //////////////////////////////////////////////

=============================================================
.BF
check_win()
.(x
checkwin
.)x
.FD
check_win(wn)
checks if valid window returns window number or -1 if invalid
.EF


=============================================================
.BF
close_laser()
.(x
closelaser
.)x
.FD
close_laser()
closes the laser graphic instruction file.


.EF
=============================================================
.BF
gs_job()
.(x
gsjob
.)x
.FD
gs_job(p1,p2,p3...)

issues the Unix command line
p1 p2 p3 &
via the job control process.
returns the job number. Use this function for the signal processing modules.
If a signal processing module has been activated,
then the job number can be used with the function f_exist to wait 
for the command to finish, before further processing or display.
(Use the function command for UNIX commands like rm,cp,cat ... etc.)
e.g.
job=gs_job("sg", "-i","demo.vox", "-o", "sg.df")
produces the Unix command
sg -i demo.vox -o sg.df
which  computes a spectrum file.
.EF
/////////////////////////////////// MENUS ///////////////////////////////////////////

=============================================================
.BF
choice_menu()
.(x
choicemenu
.)x 
.FD
choice_menu("menu_file",{mx,my})

c_menu returns the menu item value for the chosen menu item.
By default choice_menu places a menu at the current mouse location,
otherwise the user can set the menu position using the optional mx,my parameters.

.EF
=============================================================
.BF
yes_or_no_menu()
.(x
yesornomenu
.)x 
.FD
yes_or_no_menu("title")

returns the string 1 or 0 for the chosen menu item {yes,no}.
choice_menu places a menu at the current mouse location,

.EF
/////////////////////////////// STRINGS ////////////////////////////////////////////////









////////////////////////////// UTILS //////////////////////////////////////////////////

=============================================================
.BF
atoi()
.(x
atoi
.)x 
.FD
a=atoi(astring)
converts number as string to integer
An svar argument which has multiple fields of number strings will be returned as an integer array.
(see atof)

.EF
=============================================================
.BF
atof()
.(x
atof
.)x 
.FD
a=atof(astring)
converts number as string to floating point -- double
An svar argument which has multiple fields of number strings will be returned as an double array.
(see atoi)
.EF


=============================================================
.BF
conv_ascii()
.(x
convascii
.)x 
.FD
conv_ascii(&C[0],&I[0],n)
An array of chars in C of length n is transformed via a new mapping
held in integer array I of length 128.
Setting array I to values 0 to 127 gives a null transform.
If you set I[13] = 10 then carriage returns are changed to newlines.
Setting I[9] = -1 will remove tabs from the array of characters.
Can be used to chnage uppercase to lowercase and vice-versa etc.

.EF
=============================================================
.BF
cast()
.(x
cast
.)x 
.FD
cast(totype, var)

e.g
n= cast(INT_, y)
Where float variable y is cast to integer variable n.
IV= cast(INT_,Y)
float vector Y is cast to integer vector IV.
However this casting will happen if the type of the variables are known.
e.g.
int IV[];
IV = Y;
Useful in casting arguments to a procedure or function.
e.g.
foo( cast(INT_,y)).

.EF
=============================================================
.BF
decision_w()
.(x
decisionw
.)x 
.FD
a=decision_w(title_string,prompt_string,option1_string,option2_string, ...)
puts up a decision window with option boxes.
Returns the string in the option box selected by the user.
e.g.
ans = decision_w("LOG_IT","log this result ?", "YES", "NO" )

.EF
=============================================================
.BF
dec2oct ~converts decimal to octal()
.(x
dec2oct
.)x 
.FD
a=dec2oct(b)
converts decimal to octal

.EF
=============================================================
.BF
dec2hex ~converts decimal to hex()
.(x
dec2hex
.)x 
.FD
a=dec2hex(d)
converts decimal to hexidecimal

.EF
=============================================================
.BF
hex2dec ~converts hexadecimal string to decimal number()
.(x
hex2dec
.)x 
.FD
decnum=hex2dec(hexstr)

.EF
=============================================================

.BF
dec2bin()
.(x
dec2bin
.)x 
.FD
a=dec2bin(b)
converts decimal to binary representation as a string
.EF

=============================================================

.BF
bin2dec()
.(x
bin2dec
.)x 
.FD
decnum=bin2dec(binstr)
converts  binary as string e.g. ("01010011010") to decimal number 666.
.EF

=============================================================
.BF
d_frame()
.(x
dframe
.)x 
.FD
d_frame(wid,file_name,frame_number,clear_window,auto_scale)

draws a  frame from file. 
Typically data such as spectra are organized as frames in a file. 
This routine opens the file at the specified frame 
and draws it into the window,
optionally clearing the window. 
The auto_sc parameter if set to 1 uses the data in the frame to set the 
scales, if set to 2 it uses information present in the header to
set the scales,
and if set zero the current window scales are used.
.EF

=============================================================
.BF
Dewhite()
.(x
Dewhite
.)x 
.FD
Dewhite(S)
Dewhites a string variable (or array of strings)
S->Dewhite() - dewhites a string

S[a:b]->Dewhite()
would dewhite a range of an array of strings - where S is an array 

.EF
=============================================================

.BF
eatWhiteEnds()
.(x
eatWhiteEnds
.)x 
.FD
nstr=eatWhiteEnds(S)
removes white spaces from head and tail of a string variable 
(or array of strings).
Returns processed string.
.EF


=============================================================
.BF
readFrame()
.(x
readframe
.)x 
.FD
read_frame(Data_vec,file_name,start,{nframes, do_ave, skip_frame, do_delta})
reads a frame (usally a float vector) from frame file.
Can specify start frame and number of frames.
if average set to 1 the average is computed for the specified number of frames
if skip_frame is set, that number of frames is skipped between reads
if do_delta set the delta between sucessive frames is obtained
  if do_delta set greater than 1, then the deltas are preformed between frames
do_delta apart.
returns frame size or 0 if last read was an error.
e.g.
read_frame(&Data[0],tsg,seekf,Nf)
.EF
=============================================================
.BF
readChan()
.(x
readChannel
.)x 
.FD
Vec=readChannel(file_name,{chan_nu=0,starti=0, num_of_values})
reads a specified channel from a channel file.
chan_nu (default 0) specify start index (default 0)
and number of values (default all the values ) to read,

If there is an error the df_errno variable is set to a number
other than zero.
The return Vec contains the data of the channel type.
(if Vec has be already set to a type - a dynamic conversion is made).
(see readChannelTimes , _df_errno, getChannelParams).

e.g.
Vec=readChannel(fname,0)
.EF

=============================================================
.BF
readChannelTimes()
.(x
readChannelTimes
.)x 
.FD
Vec=readChannelTimes(file_name,{chan_nu=0,startime, finishtime})
reads a specified channel from a channel file.
chan_nu (default 0) specify start time (default 0)
finish time.
If finish time not specified will include all values till
end of channel time. Default start time is 0.
.EF



//////////////////////  IMAGE /////////////////////////////////

=============================================================
.BF
imop()
.(x
imop
.)x
.FD
imop(ImageArray, ["sobel","laplace","point"] || array_9x9_gain)

the imagearray (2d array) is spatially filtered either with Sobel, Laplacian 'filter' or
'kernel' -- you can also supply a 9x9 gain array

Sobel array is:
		T[0] = -1;
		T[1] = -2;
		T[2] = -1;
		T[3] = 0;
		T[4] = 0;		
		T[5] = 0;		
		T[6] = 1;
		T[7] = 2;
		T[8] = 1;

Laplace array is
		T[0] = 0;
		T[1] = 1;
		T[2] = 0;
		T[3] = 1;
		T[4] = -4;		
		T[5] = 1;		
		T[6] = 0;
		T[7] = 1;
		T[8] = 0;





.EF
=============================================================
.BF
dimage()
.(x
dimage
.)x
.FD
dimage(wid,file_name,fake_grey,n_grey_levels,cmap_start, 
min,max,h_v,zoom,{channel})

if fake_grey is 1, 
the function simulates grey levels 
(use this for monochrome displays or
laser hardcopy) otherwise the color map is used. 
n_grey_levels is the number of grey shades to use. 
This must less than or equal to the
number available in the color map (8 for 4 plane graphics, 
16 for 6 plane graphics).

cmap_start - the default sets up a grey scale starting at index 8. 
The first 8 colors are rainbow colors.
min and max - This is the range over which the grey scale 
is evenly distributed. 
A value less or equal to min is shown as white, 
greater than or equal to max will be shown as the
darkest grey.

h_v - if set to 0 the image is vertically presented as in portraits.

zoom normally set to 1. 
The image will be interpolated or sampled to fit the window size (pixels).
If it is set to 2, the window scales are used to select part of
the picture which corresponds to the scaling information in the
image file header.

channel - for files which contain a number of interleaved frames
this selects the displayed
channel -default zero if set to -1 all channels are displayed
e.g. if a spectrum file is produced from a multi-channel signal file
then this parameter enables individual channels to be displayed or
all channels to be displayed in a time-aligned fashion.

e.g.
d_image(wid,"sg.df",1,8,8,0.0,70.0,1,0)


.EF

=============================================================
.BF
exit                                       ()
.(x
exit                                       
.)x 
.FD
exit([status])
will cause an interrupt and subsequent exit from the script interpreter.
default status return 0, status can be set to indicate error return
.EF
=============================================================
.BF
exit_gs                                       ()
.(x
exitgs                                       
.)x 
.FD
exit_gs(clr_screen)
will exit the graphic package. If clr_screen is 1 the screen is cleared.

.EF
=============================================================
.BF
Exp()
.(x
Exp
.)x 
.FD
Exp(a)
returns result of exponential function
e.g.
Exp(1.0) returns 2.718281828
.EF
=============================================================
.BF
f_exist,fe()
.(x
fexist
.)x 
.FD
f_exist(file_name, mode,n_seconds)


check for data_file existence and access, 
if not there wait for upto n seconds for its creation
return value size of file or -1 
if the file does not exist after n_seconds wait.
can be used together with function command (see command) 
to synchronize signal processing and display.
The mode parameter can be used to check if user can read/write/execute
the file/directory.

mode
0	read
1       search/execute
2	write
4       read
6       read/write
7       read/write/execute
8       is a directory
10      is a file

e.g.
f_exist("sg.df", 0, 7)
or 
f_exist(job, 0, 7)
.EF
=============================================================
.BF
cmplx()
.(x
cmplx
.)x 
.FD
cmplx a  ; a is a complex number  float precision
a->set(2.5,0.5)
a->info(1)

a->setReal(3.5)   would update the real part
a->setImag(-0.7)   would update the image part

r=a->getReal()   gets the real
i= a->getImag()

R=A[1:10]->getReal() -- obtains a subrange of a Cmplx vector
A[1:10]->setReal(R) -- sets a subrange of a Cmplx vector using a float vector.

dcmplx b
b is a double precision cmplex number.
the above functions work for a dcmplx number/vector.

.EF
=============================================================
.BF
vgen()
.(x
vgen
.)x 
.FD
V=vgen(TYPE_,n,{init_val},{step})
generates a vector n values,of type (FLOAT_,INT_,SHORT_,CHAR_, CMPLX_ ...) initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.
For complex vectors each real imag pair is set to value and then the step is incremented.
(INT_  name followed by _  are internal definitions CHAR_ is 1, SHORT_ is 2, INT_,FLOAT_ ,..)
.EF
=============================================================
..BF
vga()
.(x
vga
.)x 
.FD
DV=vga(0,1,2,3.3,4,b,V)
generates a double vector using a list of args numbers or variables.
A vector of numeric values  is a valid argument.
.EF
=============================================================
.BF
matgen()
.(x
matgen
.)x 
.FD
M=matgen(TYPE,rows,cols,{init_val},{step})
generates a matrix {rows][cols] values,of type (FLOAT,INT,SHORT,CHAR, CMPLX ...) 
initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.
For complex vectors each real imag pair is set to value and then the step is incremented.
.EF
=============================================================


.BF
fgen()
.(x
fgen
.)x 
.FD
V=fgen(n,{init_val},{step})
generates a vector n values,of type FLOAT initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.

.EF
=============================================================
.BF
dgen()
.(x
dgen
.)x 
.FD
V=dgen(n,{init_val},{step})
generates a vector n values,of type DOUBLE initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.

.EF
=============================================================
.BF
igen()
.(x
igen
.)x 
.FD
V=igen(n,{init_val},{step})
generates a vector n values,of type INT initialised to  init_val (default 0),
if step is set, then value is incremented by step for each element.

.EF
=============================================================
.BF
vvgen()
.(x
vvgen
.)x 
.FD
V=vvgen(TYPE,n,init_vec,step_vec)
generates a vector n values,of type (FLOAT,INT,SHORT,CHAR, ) the first set of values (set size is that of
the init_vec size) are  initialised to the  init_vec. 
Then in the second operation values are incremented by step_vec, and placed in the next set of values. 
This is continued until the required number
of values are generated.
e.g. 
int vi[2] = {0,1}
int vs[2] = {1,2}
J = vvgen(INT_,10,vi,vs)  
J will contain
0 1 1 3 2 5 3 7 4 9

.EF
=============================================================
.BF
vfill()
.(x
vfill
.)x 
.FD
vfill (vec,N, start_index, start_value, incr_value, stepindex);

fills vector with values 
vfill(vec,Nvalues, [start_index], [start_value], [incr_value], [stepindex]);

can be used to zero vector or section of vector,
or generate a ramp of values.

.EF
=============================================================

.BF
sgen()
.(x
sgen
.)x 
.FD
V=sgen(TYPE,n,vec,{init_val})
generates a vector n values,of type (FLOAT_,INT_,SHORT_,CHAR_ ...) 
The argument vector is used to successively add values 
to the current value, while cycling through its
'list' of values - 
each new value is put into the next element of the genearated vector. 
e.g.
vec = {2,-1}
V=sgen(INT,10,vec)
would set V to   
2 1 3 2 4 3 5 4 6 5
a two steps forward one step back sequence. 
The default initial value is zero. 
The size of vec does not need to be an exact factor 
of the size of the generated array.
.EF
=============================================================
.BF
frange()
.(x
frange
.)x 
.FD
V=frange(n,start_val,end_val)
generates a vector n values, initialised to  start_val 
incremented linearly to end_val.

.EF
=============================================================
.BF
fstat,fs()
.(x
fstat
.)x 
.FD
fstat(file_name,[attribute])

check for data_file existence and reports information
depending on atribute (default type)
attribute can be :- type,mode,atime,mtime,adate,inode,size, ...
date = fstat(file_name,"cdate")
returns date of creation e.g. Tue Dec 18 06:50:20 2018
ctime, returns secs since epoch.
(see also fexist)
.EF
=============================================================
.BF
cconvolve()
.(x
cconvolve
.)x 
.FD
cconvolve(H,X)

computes a circular convolution of H (e.g. impulse) with X (signal vector).
(math)
.EF
=============================================================

lconvolve
.(x
lconvolve
.)x 
.FD
lconvolve(H,X)

computes a linear convolution of H (e.g. impulse) with X (signal vector)
H is flipped and then slid past X. At each slide position the sum of all elements 
multiplied against X are formed
and that value is output - the slide-multiply-sum operation continues until
the entire signal vector is processed. 
Length of output vector is H length plus X length.
The output type is either double or float depending on the highest type of the H,X vectors.
If X type is short it is converted to float or double before the convolve operation.
(math)
.EF
=============================================================
.BF
fft()
.(x
fft
.)x 
.FD
fft(real,imag,fft_size,{dir})
performs in place fast Fourier transform radix 2.
decimation in frequency version
if dir = 1 forward transform (default) 
if dir = -1 inverse transform
(math)
.EF
=============================================================

fftdit
.(x
fftdit
.)x 
.FD
fftdit(real,imag,fft_size,{dir})
performs in place fast Fourier transform radix 2.
decimation in time version
if dir = 1 forward transform (default) 
if dir = -1 inverse transform
(math)
.EF
=============================================================
.BF
spec()
.(x
spec
.)x 
.FD
spec(real,imag,fft_size,{code},{log10},{dif|dit})
computes 10*log10 power spectrum
 10 * log10 (re^2 + im^2)
If code set to 1 (default 0) two independent real signals are processed.
The first is placed in the real array, the second in the imag array.
The two power spectrums arrive in the output real and imag arrays.
If log10 is one (default) a 10log spectrum is output , else power spectrum.
If dif|dit arg is set to 0 a decimation in frequency fft is computed
else it is decimation in time (default).
.EF
=============================================================
.BF
powspec()
.(x
powspec
.)x 
.FD
powspec(real,imag,fft_size)
computes power spectrum
 re^2 + im^2

.EF
=============================================================
.BF
magspec()
.(x
magspec
.)x 
.FD
magspec(real,imag,fft_size)
computes magnitude spectrum  
i.e. sqrt (re^2 +im^2)


.EF
=============================================================
.BF
chdir()
.(x
chdir
.)x 
.FD
chdir(new_dir)
change directory
returns -1 if fails
.EF
=============================================================
.BF
updir()
.(x
updir
.)x 
.FD
updir()
changes to parent directory
returns -1 if fails
.EF
=============================================================
.BF
CheckMem()
.(x
CheckMem
.)x 
.FD
CheckMem(tag)
checks for tag in LTM memory and returns 1 if found
else 0
(see GetMem)

.EF
=============================================================
.BF
checkMemory()
.(x
checkMemory
.)x 
.FD
checkMemory(ON,{RESET})

Turn on/off and optionally reset memory statistics.


=============================================================
.BF
getalias()
.(x
getalias
.)x 
.FD
getalias(name)
returns path for alias which is determined from .gs_alias file in 
local GASP directory or from the set_alias function.

.EF
=============================================================
.BF
gethost()
.(x
gethost
.)x 
.FD
gethost()
returns name of host (machine name)
(also getuname())

.EF
=============================================================
.BF
getdir()
.(x
getdir
.)x 
.FD
getdir()
returns current directory


.EF
=============================================================
.BF
getenv_var()
.(x
getenvvar
.)x 
.FD
getenv_var(name)
searchs for env variable of name and returns value if found
else the string NULL
(see put_mem)

.EF
=============================================================
.BF
getMem()
.(x
getMem
.)x 
.FD
getMem(tag)
checks for tag in memory and returns its value if found
else the string NULL
(see PutMem)

.EF
=============================================================
.BF
getmdy()
.(x
getmdy
.)x 
.FD
getmdy()
returns month,day,year e.g. 11/08/96
(getmdy,gethms,getdmy,gethour)
.EF
=============================================================
.BF
getsx()
.(x
getsx
.)x 
.FD
getsx()
returns screen width in pixels
.EF
=============================================================
.BF
getsy()
.(x
getsy
.)x 
.FD
getsy()
returns screen height in pixels

.EF
=============================================================
.BF
getframe_para()
.(x
getframepara
.)x 
.FD
getframe_para(fname,para_name)
returns the parameter value for a data frame file
e.g
getframe_para(fname,"VL")
returns the frame vector length for the data file
(simarly for parameters MIN,MAX,UL,LL,STR,STP,FS,FL,N)
(see getchannel_para)

.EF
=============================================================
.BF
getdf_para()
.(x
getdfpara
.)x 
.FD
getdf_para(fname,para_name)
returns the parameter value for a data  file
e.g
getdf_para(fname,"NOC")
returns number of channels in channel type file
(see getchannel_para, getframe_para)
.EF
=============================================================
.BF
getchannel_para()
.(x
getchannelpara
.)x 
.FD
getchannel_para(fname,para_name,{channel})
returns the parameter value for a channel file
The optional channel parameter when set (default 0) will 
read the parameter value from the selected channel.
e.g
getchannel_para(fname,"FS")
returns the analysis window shift for the data file
(simarly for parameters MIN,MAX,UL,LL,STR,STP,FS,FL,N)
will return null value if not found.
(see getframe_para)

.EF
=============================================================
.BF
getsignal_space()
.(x
getsignalspace
.)x 
.FD
getsignal_space(ns)
allocates a signal buffer ns long for use in edit operations.
returns -1 if space not allocated. A subsequent call will reallocate the space
to the new size.
.EF
=============================================================
.BF
getuwat()
.(x
getuwat
.)x 
.FD
getuwat(wid)
returns octal word representing the user controlled window attributes.
e.g. whether the axes are shown, title ,cursors.
(see appendix on window attributes)

.EF
=============================================================
.BF
getswat()
.(x
getswat
.)x 
.FD
getswat(wid)
returns octal word representing the system controlled window attributes.
e.g. whether the window is currently buried,acting as a terminal etc.
(see appendix on window attributes)

.EF
=============================================================
.BF
getasl_pid()
.(x
getaslpid
.)x 
.FD
getasl_pid()
returns the pid of the script process. 


.EF
=============================================================
.BF
getwid_pid()
.(x
getwidpid
.)x 
.FD
getwid_pid(pid )
returns window number from pid. 
returns -1 if process has not been initiated via
the window manager.

.EF
=============================================================
.BF
gettitle_wid()
.(x
gettitlewid
.)x 
.FD
gettitle_wid(wid)
returns window title from window number

.EF
=============================================================
.BF
getwid_title()
.(x
getwidtitle
.)x 
.FD
getwid_title(title)
returns window number from title


.EF
=============================================================
.BF
getMouseState()
.(x
getmousestate
.)x 
.FD
MS=getmouse_state()
returns mouse state to float array MS. 
element 0 window num , -1 if mouse cursor not in window
element 1 window object number 
element 2 button state
element 3 screen x
element 4 screen y
element 5 window real X coor
element 6 window real Y coor
element 7 window x pixel
element 8 window y pixel


.EF
=============================================================
.BF
getMouseEvent()
.(x
getmouseevent
.)x 
.FD
ME=getmouse_event()
waits for an event and returns mouse state to float array ME. 
element 0 window num , -1 if mouse cursor not in window
element 1 window object number 
element 2 button state
element 3 screen x
element 4 screen y
element 5 window real X coor
element 6 window real Y coor
element 7 window x pixel
element 8 window y pixel
element 9 event time in secs
element 10 woid -- window object id ((wid<<16 + wo number).

should time out -- return on time out elements are -1;

.EF
=============================================================
.BF
getincr()
.(x
getincr
.)x 
.FD
getincr(delta)
returns a suitable value for grid or tick spacing for the interval delta.

.EF
=============================================================
.BF
getmenu_value()
.(x
getmenuvalue
.)x 
.FD
getmenu_value("menu_file","label")

The function getmenu_value searches the menu by label name to obtain the menu item value.
(see also rd_menu).
e.g.
A=getmenu_value("menu_file","label_name")
obtains the value for the menu item when the item label matches label_name.

.EF
=============================================================
.BF
getmouse_click()
.(x
getmouseclick
.)x 
.FD
getmouse_click({cursor_font1}{cursor_font2})
loads cursor_font1
waits for a button click 
loads cursor_font2
returns value of button click 


.EF
=============================================================
.BF
getplanes()
.(x
getplanes
.)x 
.FD
getplanes()
returns number of planes in the system.
.EF
=============================================================
.BF
getanswer()
.(x
getanswer
.)x 
.FD
getanswer(default_answer,"prompt ?"{,p1,p2 ...})
 
prints prompt string in a popup window - user can type answer string or hit return.
Carriage return only returns the default answer.
e.g.
f_name=getanswer(f_name,"file name ?<",f_name,">")
.EF
=============================================================
.BF
argc()
.(x
argc
.)x 
.FD
argc()

returns command line argument count - including the script.
e.g. argc() would return 3
for the script file <asl script.asl arg1 arg2>
or the exe  <./script arg1 arg2>

The internal variable _clarg is an array containing the command line arguments and script name.
so
a1 = _clarg[1]   // would get the first argument after script name.
a2 = _clarg[2]   // would get the second argument after script name.
...

also
na = Caz(_clarg)  
 would also give the number of command line arguments (including the script).
(see _clarg)



.EF
=============================================================
.BF
getarch()
.(x
getarch
.)x 
.FD
getarch()

returns string indicating machine architecture,
e.g. sun,i386, mc6000 

.EF
=============================================================
.BF
getdir()
.(x
getdir
.)x 
.FD
getdir(&text[0])
 Will place in test the current working directory.
return number of characters
can be used as cwd=getdir()
where with null argument will return cwd 


.EF
=============================================================
.BF
getsf()
.(x
getsf
.)x 
.FD
getsf(wid)
returns sampling frequency of signal buffer.

.EF
=============================================================
.BF
GetSRT()
.(x
GetSRT
.)x 
.FD
sr=GetSRT(wid)
returns into float array sr the select region times, 
duration sr[0] ,start sr[1],stop sr[2],buffer_end_time sr[3],sample_frequency sr[4] and buffer_number sr[5]
of signal buffer connected to window wid.


.EF
=============================================================
.BF
getsw_fn()
.(x
getswfn
.)x 
.FD
getsw_fn(name)
if name is a window title the functions builds a header file which allows signal
processing modules to access the window signal buffer and returns the header file
name. Otherwise the functions returns the original name.

.EF
=============================================================
.BF
gsockcreate,socket()
.(x
gsockcreate
.)x 
.FD
gsockcreate(ipname, port, protocol [TCP, UDP], type [SOCK_STREAM, SOCK_DGRAM], domain [AF_INET])
 Creates a socket. This can be of type  UDP-- User Datagram Protocol 
that is a connectionless, unreliable datagram packet service or
TCP provides a reliable, stream-oriented,  full-duplex connection between 
two sockets on top of ip(7), for both v4 and v6 versions.  
The default is TCP, SOCK_STREAM , AF_INET. If UDP is specified then the type will be
SOCK_DGRAM.
e.g.

sock_handle=gsockcreate("local",9871)
or
gsockcreate("129.239.252.62",9871, UDP)
or
gsockcreate("any",9871)

(see sendto,recv,recvfrom, accept,bind, connect)

.EF
=============================================================
.BF
gsocksendto,sendto()
.(x
gsocksendto
.)x 
.FD
gsocksendto(sock_handle, msg , [nbytes])


.EF
=============================================================
.BF
gsockbind,bind()
.(x
gsocksendto
.)x 
.FD
bind(sock_handle)


.EF
=============================================================
.BF
gsockrecv,recv()
.(x
gsockrecv
.)x 
.FD
msg = gsockrecv(sock_handle,[nbytes])

.EF
=============================================================
///////////////////////////////// TIME - DATE ///////////////////////////////////



.BF
ctime()
.(x
ctime
.)x 
.FD
ctime(secs)
returns date from UNIX seconds
i.e. number of seconds since 
January 1, 1970, Coordinated Universal Time (UTC).

.EF
=============================================================
.BF
utime()
.(x
utime
.)x 
.FD
utime() (or gettime() )
returns Unix time in seconds.

.EF
==========================================================
.BF
getday()
.(x
getday
.)x 
.FD
getday()
returns day (1-31) of current month.
(see also getmonth,getyear, gethour,getminute,getsecond, gethms, getmdy)
needs tools/LIB/date.g as include file at begining of script to access these
functions
e.g
include tools/LIB/date.g

.EF
=============================================================
.BF
getdate()
.(x
getdate
.)x 
.FD
today= getdate(form)
returns date string string depends on form parameter
form (1-17)
if form = 1 string is as in UNIX date command
form = 2 month/day/year
form = 5 (ISO8601) year-month-day hour:minute:second
form = 17 week day

jd = julian(date(2))
gives the juilan day;

ds= julmdy(jd)
would return the date for the julian day

(see also getday(),gethour(),julian(),...)


.EF
=============================================================
.BF
getdir()
.(x
getdir
.)x 
.FD
cwd= getdir()
returns current working directory


.EF
=============================================================
.BF
FineTime()
.(x
FineTime
.)x 
.FD
FineTime()
returns Unix time in seconds and micro (10^-6) secs to a uint array
e.g.
T=FineTime()
FineTimeSince can be used to give difference in micro seconds between times
e.g.
dt=FineTimeSince(T)

the time array can be updated if called with extra parameter
dt=FineTimeSince(T,1)
now T is updated.

.EF
=============================================================
.BF
julian()
.(x
julian
.)x 
.FD
jday=julian(month,day-of-month,year)
given month(1-12),day(1-31), year xxxx
returns the julian day using Julian calander,
remember first year AD is year 1 (not zero)
-1 first year (BC)
and
date_mdy= julmdy(jday)
would return the date m/d/yr   for a julian day.
.EF
=============================================================
.BF
juldayofweek()
.(x
juldayofweek
.)x 
.FD
juldayofweek(julianday)
e.g. juldayofweek(julday(2,10,2010))
Julian day 2440000 began noon May 23 1968
1721424 was 1,1,1 first day A.D.



////////////////////////////  GWM IO /////////////////////////////////////////

=============================================================
.BF
GetWinRS,getScales()
.(x
GetWinRS
.)x 
.FD
rs=GetWinRS(woid)
returns real scales value for window/wob wid in float array rs,
returns wid in rs[0], x,y,X,Y in rs[1] to rs[4]




.EF
=============================================================
.BF
getw_curs()
.(x
getwcurs
.)x 
.FD
getw_curs(wid,nu,xy)
returns the position relative to the real coors of the window wid of 
the cursor icon nu. If xy is set to 1 the x position is returned,
if set to 0 the y position is returned.




.EF
=============================================================
.BF
getversion()
.(x
getversion
.)x 
.FD
getversion()
returns version number
  

.EF
=============================================================
.BF
wogetposition, wogetclip()
.(x
wogetclip,wogetposition
.)x 
.FD
I=wogetclip(woid) , I = wogetposition(woid)
gets the clip values for a window object and returns them to an integer array
I[0] is woid or -1 if woid invalid.
then the clip region in screen coors is in
Clip x,y,X,Y are I[1],I[2],I[3],I[4]
deltaclipX I[5], deltaclipY I[6]
the window object boundaries containing the clip area are in
I[7],to I[10]
and the parent window boundaries are in
I[11] to I[13] 

.EF
=============================================================
gets the clip values for a window object and returns them to an integer array
I[0] is woid or -1 if woid invalid.
then the clip region in screen coors is in
Clip x,y,X,Y are I[1],I[2],I[3],I[4]
deltaclipX I[5], deltaclipY I[6]
the window object boundaries containing the clip area are in
I[7],to I[10]
and the parent window boundaries are in
I[11] to I[13] 

.EF
=============================================================
.BF
getWoValue()
.(x
getwovalue
.)x 
.FD
getwo_value(wo_id)
gets the current value (as a string)  of window object with id wo_id.

.EF
=============================================================
.BF
Hist()
.(x
Hist
.)x 
.FD
H=Hist(A,size,{min,max})

vector A is divided into bins each size wide 
in the range min (default zero) to max (default - max value of A).
If max is not set the routine finds the maximum value in the vector and uses that value.
The bin contains all values between its lowest value and upto but not including value + size.
 A bin is incremented when the value of element A falls within its sub-range.





.EF
=============================================================
.BF
Igen,igen()
.(x
Igen
.)x 

.FD
A= Igen(n,{start_value,step_value})
returns a int vector of n numbers 
will be initialize to zero, but a start_value
and step increment can be optionally specified
.EF
=============================================================
.BF
scrlaser()
.(x
scrlaser
.)x 
.FD
scrlaser(wid)
resizes the window ready for laser output device
.EF
=============================================================
.BF
laserscr()
.(x
laserscr
.)x 
.FD
laserscr(wid)
resets the window from laser(printer coors) to the screen 
.EF
=============================================================


.BF
Log,log()
.(x
Log
.)x 
.FD
Log(a)
returns natural log

.EF
=============================================================
.BF
Mdimn()
.(x
Mdimn
.)x
.FD
Mdimn(M,{n,m,p,..})
redimensions a multidimension array.
If no dimensions are specfied a single dimension array is formed,
otherwise the the product of the dimension must equal the current number of elements
in the multidimension array M.
Returns new matrix,array
e.g. F= Mdimn(A,3,2)
(see Vec)

.EF
=============================================================
.BF
minmax()
.(x
minmax
.)x 
.FD
mm=minmax(A)
examines array A returns min and max
to first and second values respectively in float array mm.

.EF
=============================================================
.BF
minof()
.(x
minof
.)x 
.FD
min=minof(a,b,...)

 returns the minimim value (double) of the supplied arguments.

.EF
=============================================================
.BF
maxof()
.(x
maxof
.)x 
.FD
max=maxof(a,b,...)

 returns the maximum value (double) of the supplied arguments.




.EF
=============================================================
.BF
minmaxi()
.(x
minmaxi
.)x 
.FD
mm=minmaxi(A)
examines array A returns indice of  min and max to
to first and second values respectively in int array mm.

.EF
=============================================================
.BF
mix()
.(x
mix
.)x 
.FD
mix()

The cut/paste buffer is mixed (added to current samples)
into  the buffer associated with window wid at the 
start of the select region. (see paste)



.EF
=============================================================
.BF
mul_signal()
.(x
mulsignal
.)x 
.FD
mul_signal(wid,x,sample_number_1{,sample_number_2})
 
multiplys x to the signal present in the signal buffer associated with window wid,
from sample_number_1 to sample_number_2. 
The sample_number_2 parameter is optional. 

mul_signal(wid,x,0) will operate on  the entire buffer.
mul_signal(wid,x,1) will operate on  the select region buffer.
mul_signal(wid,x,s1,s2) will operate on  the region s1 to s2 inclusive.

.EF
=============================================================
.BF
o_file,ofile,ofw,ofr()
.(x
ofile
.)x 
.FD
o_file(file_name,permissions)

opens a file_name with permissions
returns file handle  ( 1 , 2 , 3 ...) or -1 if error (also si_error is set).
	r+   read and write
	r    read only
	w+   open for writing
e.g.
A=o_file("labfiles","r+") ;
if this is the first file opened in ASL , A will contain the 1 if successful.

ofw(fname) - opens file for writing
ofr(fname) - opens file for reading



.EF
=============================================================
.BF
popen()
.(x
popen
.)x 
.FD
A=popen(command,"[r,w]")
invokes popen unix command - 
a shell process is started and either reads from file descriptor or writes.
returns file pointer index ( 1 , 2 , 3 ...) or -1 if error (also si_error is set).





.EF
=============================================================
.BF
oct2dec()
.(x
oct2dec
.)x 
.FD
a=oct2dec(b)
converts octal to decimal 


.EF
=============================================================
.BF
open_laser()
.(x
openlaser
.)x 
.FD
open_laser(file_name,[land=0],[fntsize=12])

opens a file which will contain instructions (default postscript) for plotting to a 
laser printer. The Unix command line
cat file_name | rsh machine_name lpr
will result in laser hardcopy. If the machine has a postscript printer.
The optional args allow setting to lanscape or portrait (def postrait)
and the general font size (def 12).
Font size can be set for any indiviual text (or window object)


.EF
=============================================================
.BF
paintlabels()
.(x
paintlabels
.)x 
.FD
paint_labels(ls,woid,show_times,y_pos,v_h)
paints a label set in window object via it's id  woid.

if show_times puts a vertical line at start and stop.
the labels are placed at y_pos (fraction 0 bottom 1.0 top)
labels can be vertical or horizontal v_h (1,-1)
if show_times set to 2 - the labels are not shown.

.EF
=============================================================
.BF
paint_line()
.(x
paintline
.)x 
.FD
paint_line (wid,x,dir)
paints a line in window wid at x . If dir = 1 vertical line, if dir 0 horizontal line.


.EF
=============================================================
.BF
place_curs()
.(x
placecurs
.)x 
.FD
place_curs( wid,x,width,dir,nu)
places a cursor line in window wid at x.
If dir = 1 vertical line, if dir 0 horizontal line.
nu is cursor identification number,
so that a subsequent call with the same number would remove
the previous cursor image (i.e. shift the cursor to the new location ).
(see also getw_curs)

.EF
=============================================================
.BF
paste()
.(x
paste
.)x 
.FD
paste(wid)

The cut/paste buffer is pasted (replacing current samples)
into  the buffer associated with window wid at the 
start of the select region. ( see mix).


.EF
=============================================================
.BF
playsignal,playbuffer()
.(x
playSignal
.)x 
.FD
playsignal(dspfd, sbn,{sample_number_1, {sample_number_2}, {scale_factor =1})

plays the signal present in the signal buffer (selected by number) ,
from sample_number_1 to sample_number_2. 

e.g.
play_signal(dspfd,sbn, s1,s2) will play the signal inclusive between sample s1 and sample s2.
play_signal(dspfd,sbn, 0,-1,2) will play the entire signal with a gain of 2.


.EF
=============================================================
.BF
play_sr()
.(x
playsr
.)x 
.FD
play_sr(wid)
plays the signal for the select region of the buffer associated with
window wid
requires 
include playrec.g 
in sip script
(see also play_buffer(wid),play_window(wid) )

.EF
=============================================================
.BF
playSignalTimes()
.(x
playsignaltimes
.)x 
.FD
play_signal_times(wid,time1, time2)
 
plays the signal present in the signal buffer associated with window wid,
from time1 to time2. 


.EF
=============================================================
.BF
plot_chan()
.(x
plotchan
.)x 
.FD
plot_chan(wid,f_name,channel_nu,line_type,symbol_nu,symbol_size, scale_type)
 
plots the specified parameter track (channel) out of named file 
in the current window.
If symbol_number is zero no symbols are plotted, 
otherwise the chosen symbol is 
plotted at each x,y point. 
If line_type is zero, no connecting line between (x,y)
points is plotted. 
Symbol size is a percentage of the clip region size.
The plot can be scaled as follows :-
scale_type = 0 - auto scaled to maximum/minumum of data values
scale_type = 1 - use data file header to scale plot window
scale_type = 2 - use current window settings
default is 0
e.g.
plot_chn(w1,df_name,0,1,0,5)


.EF
=============================================================
.BF
Pulse()
.(x
Pulse
.)x 
.FD
Pulse(A,pwidth,{polarity, delay})



.EF
=============================================================
.BF
putMem()
.(x
putMem
.)x 
.FD
putMem(tag,value,[overwrite = 0])
checks for tag in memory and replaces its value if found and overwrite is set (default notset)
or if not found enters a new tag-value pair.



.EF
=============================================================
.BF
sleep,si_pause()
.(x
sleep
.)x 
.FD
sleep(seconds)
wait seconds then continue.
seconds can be specified to millisec resolution e.g. 1.002
but resolution unlikely to be better then tenths of sec

.EF
=============================================================
.BF
nanosleep,()
.(x
nanosleep
.)x 
.FD
nanosleep([seconds], nanosecs)
wait seconds plus nanoseconds then continue.
if only one argument is given then used as nanoseconds.
Unknown what the resolution really is, but function is thread safe.



.EF
=============================================================
.BF
set_com_pause()
.(x
setcompause
.)x 
.FD
set_com_pause(n_seconds)
message communication (via pipes) between sip process and xgs (graphic module)
requires waiting for processing and reply - default wait interval is 0.002 secs
set_com_pause allows this to be set.


.EF
=============================================================
.BF
print()
.(x
print
.)x 
.FD
print(p1,p2,p3)

wait print the parameters in the HELP window.
e.g.
print(A," is less than ",B) 


.EF
=============================================================
.BF
query()
.(x
query
.)x 
.FD
ans=query("type name ->:")
puts prompt string.
reads typed string into variable 


.EF
=============================================================
.BF
query_w()
.(x
queryw
.)x 
.FD
query_w(W_TITLE,prompt_string,default_answer)
puts up a window with a prompt string. Returns a
a string which the user has typed or modified.
The window has 4 option boxes :-
 OK    ?    >    QUIT

The user may indicate acceptance of the default_answer
by clicking the OK box, or modify the string after
clicking the ? box. A new string may be input after
clicking the > box. Clicking the QUIT box returns the
string 'NULL'.



.EF
=============================================================
.BF
Rand()
.(x
Rand
.)x 

.FD
A= Rand(n,max,[replacement],[seed])
returns a vector of n random numbers in range (1 to max)
or a single number if called with no arguments
if max is not specified the numbers will be in the range 0 and RAND_MAX (32767)
as defined in Unix math rand() function.
If replacement is set to zero then a number once 'picked' is removed from the set of numbers.
If the seed variable is supplied then if positive it is used to seed the random number generator.
(if <= 0 then Unix time is used to seed the generator).
alternatively use randseed(num) to seed the random function- 
or randseed() with no arguments uses unix time function to seed the random generator.
e.g. 
P = Rand(6,42,0,0)
would be a pick for the Lotto.
V= Rand(1000,100) 
would give a vector of 1000 numbers each value between 1 - 100.

.EF
=============================================================
.BF
Urand()
.(x
Urand
.)x 

.FD
A= Urand(n,{seed})
returns a float vector of n uniform random numbers in range (0.0 to 1.0)
If seed is 0 then unix time is used to generate a seed.

returns a single number if called with no arguments
r=Urand()
if called
as r=Urand(0)
uses unix time is used to generate a seed and returns a scalar.
if called
as r=Urand(-a)
uses  -a  as seed and returns a scalar.




.EF
=============================================================
.BF
Grand()
.(x
Grand
.)x 

.FD
A= Grand(n,[seed])
returns a float vector of n Guassian random numbers mean zero and unit variance.
returns a single number if called with no arguments
If seed is 0 then unix time is used to generate a seed.
e.g. RF= grand(100,7)


.EF
=============================================================
.BF
Minv()
.(x
Minv
.)x 

.FD
Minv(M)
returns inverted matrix the original is not altered
matrix type has to be float
e.g.
 A = Minv(M)


.EF
=============================================================
.BF
Determinant()
.(x
Determinant
.)x 

.FD
Determinant(M), Mdet(M)
returns determinant of a matrix
e.g. d = Mdet(M)






.EF
=============================================================
.BF
read_image()
.(x
readimage
.)x 

.FD
a=read_image(wid,fname,{offx,offy})
displays image from file ( see save_image) in clip region.
If offx and offy are set greter than 0 then a portion of image is
displayed. If the clip area is smaller than image then the image
is truncated.


.EF
=============================================================
.BF
MessageRead()
.(x
MessageRead
.)x 

.FD
msg=MessageRead([Minfo])
checks for messages. Ascii text is returned to msg indicating the type of message.
If there is no message then msg = "NO_MSG"
A integer array Minfo is filled
(see MessageWait )

.EF
=============================================================
.BF
MessageWait()
.(x
MessageWait()
.)x 

.FD
msg=MessageWait([Minfo],[Rinfo])
waits for message from the xgs window manager (mouse-click, keyboard , from application windows)

if called with arg Minfo an integer array then following information is returned :-
Minfo[0]  message type   (0 invalid)
Minfo[1]  id of process window 
Minfo[2]  id of window which sent message
Minfo[3]  id of window object which sent message
Minfo[4]  time of event in seconds since epoch
Minfo[5]  milliseconds 
Minfo[6]  wo num
Minfo[7]  event type
Minfo[8]  event state
Minfo[9]  event x  val (if keyboard then val is key char val)
Minfo[10]  event y  val
Minfo[11]  event id

The float array Rinfo (optional arg) is also filled 
Rinfo[0]  1.0 if inside the window clip area
Rinfo[1]  x value
Rinfo[2]  y value









.EF
=============================================================
.BF
readSignal()
.(x
readsignal
.)x 

.FD
readSignal(bufno,file_name, 
	{maximum_duration(secs) default all},
	{file_start_time=0},
	{buffer_start_time=0},
	{rescale_factor=1},
	{channel_number=0},
	{auto_scale=0},
	{byte_offset,signal_sample_frequency,type,swap_bytes} ) 

to read a signal file into a signal buffer. 
The default form assumes an a header file, 
but the optional parameters allow reading of non_header files starting
at any specified (byte) offset.
Default type is short integer.

If rescale factor is set signaled is multiplied by that factor.
If auto_scale is 1 then the signal is scaled to fit into the D/A range
by the rescale factor (i.e. factor of 0.99 would not clip 1.1 would clip 0.5 would occupy
 half of the DA range),
 
If duration is zero ,then the whole signal file is read into the buffer,
else a portion of the signal is read in, the function knows the length of the signal
so only the signal availiable will be read.
The function returns the actual number of samples read.

e.g.

read_signal(sbn,"vox_file")
to read the whole signal into the buffer.
read_signal(sbn,"vox_file",5.0,3.0)
read 5 seconds of signal starting three seconds into the file.
read_signal(sbn,"vox_file",5.0,3.0, 2.0)
read 5 seconds of signal starting three seconds into the file,
at a buffer time of 2 seconds.
So this function can be used to mix and edit signals.






.EF
=============================================================
.BF
read_signal_array()
.(x
readsignalarray
.)x 

.FD
read_signal_array(&S[0],file_name,buffer_start_time,
	maximum_duration,file_start_time,rescale_factor,channel_number,
	{byte_offset,signal_sample_frequency,type,swap_bytes} ) 

to read a signal file into an array (short int). 
The default form assumes an a header file, 
but the optional parameters allow reading of non_header files starting
at any specified (byte) offset.
Default type is short integer.
If rescale factor is greater than zero, 
then the signal is scaled to fit into the D/A range by that factor. 
If duration is zero ,then the whole signal file is read into the buffer.
The function returns the actual number of samples read.

e.g.
read_signal_array(&S[0],"vox_file",0.0,3.0,0.0,0.0,0)
or simply
read_signal_array(&S[0],"vox_file")


.EF
=============================================================
.BF
getlabel_count()
.(x
getlabelcount
.)x 
.FD
getlabel_count(label_set)
 returns number of labels in set

.EF
=============================================================
.BF
getlabel_name()
.(x
getlabelname
.)x 
.FD
getlabel_name(label_set,tok)
 returns label name
error return  NULL


.EF
=============================================================
.BF
setap()
.(x
setap
.)x 
.FD
setAP(n)
sets and returns the precision used by the extended precision library
pan type  uses base 256
e.g
setAP(100)
pan F = exp(1)
pan F would be the constant e with a precision of a 100  places
pan F = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166369
.EF
=============================================================
.BF
search_label_time()
.(x
searchlabeltime
.)x 
.FD
search_label_time(label_set,the_time,{start_tok,condition})
condition   returns token number 
-1  stop_time < the_time
1    that has closest mid-point time to the_time
2   start time > the_time
3   start  <= the_time
4   start  >= the_time

search starts from start_tok (default 1).
error return  -1
(see search_label)


.EF
=============================================================
.BF
searchile()
.(x
searchfile,fsearch
.)x 
.FD
searchFile(fpt,string,{end,dir,case_dep,seek_bytes,seek_origin})
fsearch(fpt,string,{end,dir,case_dep,seek_bytes,seek_origin})

searches the file pointed to by fpt for the target string,
returns the file position (long bytes) after the search or -1 if target not found. 
If end is set to 0 the position  at 
the start of the target is returned.
If dir set to -1 search direction is reversed.
If case_dep set to 0 the search is independent of upper or lower case.
Default is case sensitive.
if seek_origin set to zero - seek seek_bytes from begining of the file before searching.
if seek_origin set to 1 - seek seek_bytes from current position of the file before searching.
if seek_origin set to 2 - seek seek_bytes (should be negative) from end of the file before searching.

.EF
=============================================================
.BF
searchLabel()
.(x
searchlabel
.)x 
.FD
search_label(label_set,name, {start_tok,direction})
 returns first token number that matches name
search starts from start_tok (default 1).
If direction equals -1 reverse search
error return  -1
(see search_label_time)
 
.EF
=============================================================
.BF
delete_label()
.(x
deletelabel
.)x 
.FD
delete_label(label_set,tok)
deletes token from set
error return  -1
 
.EF
=============================================================
.BF
add_label()
.(x
addlabel
.)x 
.FD
add_label(label_set,name,start,stop)
adds token to set
returns its number
error return  -1
 
.EF
=============================================================
.BF
edit_labels()
.(x
editlabels
.)x 
.FD
edit_labels(label_set,index,s1,s2,[dir])
for a label set substitute s2 for s1 in label name for label index.
if index == -1 for all items.
dir default 2 does global substitute, dir 1 from left, dir -1 from right

 
.EF
=============================================================
.BF
rename_label()
.(x
renamelabel
.)x 
.FD
rename_label(label_set,tok,new_name)
renames token with new_name
error return  -1
 
.EF
=============================================================
.BF
getlabel_start()
.(x
getlabelstart
.)x 
.FD
getlabel_start(label_set,tok)
 returns label start time in seconds
error return -1



 
.EF
=============================================================
.BF
set_label_times()
.(x
setlabeltimes
.)x 
.FD
set_label_times(label_set,tok,start,stop)
 sets label start and stop time in seconds
error return -1
 

.EF
=============================================================
.BF
getArgI()
.(x
getArgI
.)x 
.FD
getargI 
getArgI(1)
returns nth Command Line arg as an int.
internal array _clarg   holds command line args
.EF
=============================================================
.BF
getArgF()
.(x
getArgF
.)x 
.FD
getargF
getArgF(n)
returns nth Command Line arg as a float.
 internal array _clarg   holds command line args
.EF
=============================================================
.BF
getArgStr()
.(x
getArgStr
.)x 
.FD
getargStr 
getArgStr(n)
returns nth Command Line arg as a str.
internal array _clarg   holds command line args
.EF
=============================================================


.BF
getlabel_dur()
.(x
getlabeldur
.)x 
.FD
getlabel_dur(label_set,tok)
 returns label duration in seconds
error return -1
 
.EF
=============================================================
.BF
getlabel_set()
.(x
getlabelset
.)x 
.FD
getlabel_set(max_labels)
gets a set of lables returns the label_set number
used for manipulating tokens
error return -1
 
.EF
=============================================================
.BF
reset_label_set()
.(x
resetlabelset
.)x 
.FD
reset_label_set(label_set)
re_initializes a label set
error return -1
 
.EF
=============================================================
.BF
getlabel_stop()
.(x
getlabelstop
.)x 
.FD
getlabel_stop(label_set,tok)
 returns label stop time in seconds
error return -1.


.EF
=============================================================
.BF
read_timit_labels()
.(x
readtimitlabels
.)x 
.FD
read_timit_labels(label_set,file_name)
(r_labels)
reads a set of timit data base labels into label_set.
returns number of labels read.
(see get_label_set, read_labels)


.EF
=============================================================
.BF
sort_label_set()
.(x
sortlabelset
.)x 
.FD
sort_label_set(label_set)
sorts in order of start_time the label set.
removes duplicate labels.
returns number (new) of labels in the set.

.EF
=============================================================
.BF
ttyin,iread()
.(x
ttyin
.)x 
.FD
ttyin()
reads a word from stdin - teletype
iread(" please enter a number:")
will print prompt string
e.g. 
wd=iread("type word on keyboard - hit enter to accept:)

wd will contain the string entered -- minus the carriage return (enter character)
(see ireadln) 
.EF
=============================================================

.BF
ireadln,irs()
.(x
irs
.)x 
.FD
irs(ans,{prompt})
reads a line from stdin - into ans, 
ans can be a svar(varchar) or an ascii variable.
If undeclared ans will be dynamically created as sivar type.
returns length of input string.


.EF
=============================================================
.BF
retype, ()
.(x
retype
.)x 
.FD
retypes a variable or a vector to a different type.
but with no memory conversion.
e.g.
F=vgen(DOUBLE_,10,0,1)

retype(INT_,F)
or
F->retype(INT_)

the vector of 10 doubles is 'relabelled' as a vector of 20 integers.

To convert to required type and maintain the size of the vector use Cast()
(see cast)


.EF
=============================================================
.BF
rwdfile()
.(x
rwdfile
.)x 
.FD
rwdfile(A)

reads a word from current position in file
e.g.
word=rwdfile(A)
returns EOF if end of file detected.
Also the routine f_error will return 6 (EOF_ERROR) if an EOF error occurred.
test using err=ferror(A)
.EF
=============================================================
.BF
readwords()
.(x
readWords
.)x 
.FD
readWords(A,Wd,{skip_lines},{delchar})
reads words from a line from current position in file
into SVAR W. The optional parameter repositions
to the start of a line (0 current line, or skips line forward,
or backward, before the read)
returns number of words read
at end of file returns -1
e.g.
A=ofr("a.vox")
nwr=readwords(A,Wd)
An alternate form is
Wd->readWords(A,{skip_lines}) 
which returns number of words read and also allows for positioning
in file in terms of lines from current line.



.EF
=============================================================
.BF
readwstokens()
.(x
readwstokens
.)x 
.FD
Wd->readWsTokens(A,{skip_lines}) 
reads words from a line from current position in file
into SVAR Wd.
Wd[0] containts the line read.
Wd[1],Wd[2], ...  contains tokens delimited by white space.

The optional parameter repositions
to the start of a line (0 current line, or skips line forward,
or backward, before the read)
returns number of words read
end of file returns -1

.EF
=============================================================
.BF
rc_file,rcfile()
.(x
rcfile
.)x 
.FD
rc_file(A,C,{n})

reads characters from file A (if A is 0 then from stdin ) to char array C.
By default reads till end of line or if n is set then n characters are read.
returns number of characters read or -1 if error.
(see wc_file)

.EF
=============================================================
.BF
readline()
.(x
readline,getline
.)x 
.FD
C=readline(A,[max_chars=-1],[remove_cr=0])
A is the file handle (0 stdin is the default);
reads an entire line (or at most max_chars if set) from the current file position
into a string  variable.
The CR/LF character is included unless the remove_cr option is set;
Setting max_chars to minus 1 means line length is unlimited ( resource limited by system),

If there is an error e.g. end of file then a file status error is set.
The function ferror(A) returns the current error if set.
End of file error is  EOF_ERROR_ value 6.
so the statement

   if (ferror(file_handle) == EOF_ERROR_) break;

will exit the read loop when end of file condition is reached. 


.EF
=============================================================
.BF
readfile()
.(x
readfile
.)x 
.FD
C=readfile(A)
reads the entire  file attached to file handle  A into svar variable C
or
C=readfile("filename")
where the file is opened then read and then closed.
line 0 is C[0], line 1 is C[1], ...
the line will contain the final cr/lf character.
The last character cr \n can be removed using option
C=readfile(A,1) that element in svar C will then be null.
Caz(C) gives number of lines read.

e.g.
A=ofr("afile.txt")
C=readfile(A)

<<"$C[0]"  // prints the first line
<<"$C[2]"  // prints the second line
...



.EF
=============================================================
.BF
pcl_file()
.(x
pclfile
.)x 
.FD
pcl_file(A,B,[# of lines to print])

prints the current line in the file, to file B (B=1 - stdout)
returns position at end of line.
Default to print one line, (print can be set to 0- no print)

alternate form
pcl_file(A,B,j,k,[print])
prints lines from position j to position k in file
returns position at end of last line printed.
.EF
=============================================================
.BF
seek_line()
.(x
seekline
.)x 
.FD
seek_line(FH,[line])
in file referenced by file handle FH
seek to beginning of line (line = 0 current, -n previous nth,n next nth)
from current position in file
return posn (ftell)  in file


.EF
=============================================================
.BF
rd_label_vox()
.(x
rdlabelvox
.)x 
.FD
rd_label_vox(file_name)
opens and reads the data file associated with a label file into the signal buffer and
draws the signal.


.EF
=============================================================
.BF
rd_menu()
.(x
rdmenu
.)x 
.FD
rd_menu("menu_file",item_num)

The function rd_menu can be used to obtain any menu item value.
e.g.
A=rd_menu("menu_file",0)
obtains the value for the first menu item of the menu.

.EF
=============================================================
.BF
ReadAscii()
.(x
ReadAscii,rascii
.)x 
.FD
R=ReadAscii(A,"type",{tar_col,tar_val})
reads ascii data converting to type into array R
which has the dimensions of rows = number of lines read
cols = number of words (white space delimited) in the first line
Data converted type can be :- int,char,short,float,double
A line can optionally be selected if particular col (tar_col)
equals a value (tar_val)
By default a line starting with # is treated as a comment line and not
processed


.EF
=============================================================
.BF
ReadTable()
.(x
ReadTable
readrecord
.)x 
.FD
R=ReadTable(A,[ OPTIONS ])

R=ReadTable(A,[@type,RECORD_],

reads a file/table  of ascii records into an array of Svars - 
each row is an Svar - each word (or delimited field) is an element of the row Svar.



MI=ReadTable(A,[@type,INT_],
reads a file of ascii records into an integer 2D array.  

MF=ReadRecord(A,[@type,FLOAT_],
reads a file of ascii records into an float 2D array.


A selection of rows and fields can be made at the initial read using pickrow, pickcol options.

[@pickrow,column,value],
[@pickcond,"<=",column,value],
[@pickrange,column,value1,value2],
[@pickbetween,column,value1,value2],
[@skip,nskiprecords],[@nrecords,nr],[@del,','])

 will read an ascii file of records optionally converting to type ("int","double","float","char")
  The type governs the conversion - float,double will use atof to convert the ascii field,
 int will use atol.
 The function returns a two dimension array of rows, columns
 corresponding to records in ascii file.

Any line starting with # is treated as comment line.
The default comment is a # as first character on a line.
The comment str can be changed with an option
[@comment, string]
so 
[@comment, "*"]  would ignore records starting with a * character.

The delmiter between record fields is white spaces but can be selected
[@del,',']
would use a comma as in csv files.

If option pickrow is specified - only those records
where the target column matches the target value are selected.

For option pickcond a condition may be added
e.g. "<="   this condition is tested and if true the record is accepted.

The following conditions (<,>,<=,>=,!=,==) can be specified
- the default is (==)
i.e. the column value has to equal the test value.

Option pickrange selects rows that are >= value1 and <= value2
Option pickbetween selects rows that are > value1 and < value2


More than one target column can be specified - all have to be true for record to be selected.
If skip is specified - then nskiprecords (not comment lines) are skipped before selection takes place.

If nrecords are specified then that  maximum number of suitable records are attempted to read.

The dimensions of returned array indicted number of records read.

The actual number of columns in the output matrix are selected
by default to be the same as the number of
fields in the fixed ascii records -- however the fields can be selected.
The number of output cols can be set to a number if less than the input number of columns
this results in only the first n columns being selected.
[@ncols, n].

You can supply an integer array with the indices of the record fields you want selected.
[@selcols, SV]  where SV is a vector with the requested field indices  e.g. int SV[] = {1,3,14} ; 


.EF
==========i======================================

.BF
findRecord()
.(x
findRecord(Str pat, int case_s, int wrd_match, int start_row, int start_col, int dir)
.)x 
.FD
Record R

wrec = R.findRecord(Str pat, int case_s, int wrd_match, int start_row, int start_col, int dir)

findRecord is a method of Record class which searches for a pattern in the Record data
case_s = 0  not case sensitive
wrd_match = 1 exact match else  partial word(column) match
start_row    - which row to start search
start_col  - start each row search at specified col
dir   if negative  search from start col to the start of row 

.EF
=============================================================

.BF
WriteTable()
.(x
WriteTable,writerecord
.)x 
.FD
WriteTable(A,Record,[ OPTIONS ])
WriteTable(A,Array,[ OPTIONS ])

  Writes a record variable or a 2d array as rows of ascii values to file (A is a filehandle).

.EF
=============================================================
.BF
sortRows()
.(x
sortRows,recSortRows
.)x 
.FD
sortRows (Rec,col, alphan, dir, si)
use specified col to sort a record table (data set).
alphan = 1 - sort by alpha char value (else numeric)
dir (1,-1)   ascending, descending order
si (0) - start index of record to use - default 0.


.EF
=============================================================
.BF
deleteRows()
.(x
deleteTows
.)x 
.FD
deleteRows (Rec,srow,frow)
 The rows in a record from srow upto and including frow are deleted.
 If frow is set to -1 (ALL_) all rows from srow are deleted.

deleteRows (Rec,vrow,nrows)

 If integer vec contains row indices then these will be deleted from the
 record ( the first set (nrows) from the vector are used).

.EF
=============================================================

.BF
rdata()
.(x
rdata
.)x 
.FD
R=rdata(A,"int",{maxitems})
reads binary data into vector R.
Data type can be :- int,char,short,long,float,double
the maxnumber of items to be read can be optionally specfied,
otherwise size of the vector e.g. sz= Caz(R) 
indicates number of items read from file.
(see wdata)

.EF
=============================================================
.BF
rwl_file()
.(x
rwlfile
.)x 
.FD
rwl_file(A,n,{sp},{end },{skip_n_lines})

get a line from current position in file and
reads the nth word.
if sp set it will seek to position sp (from start,current or end,
depending whether end is set to 0,1,2) in file before reading line.
returns EOF if end of file detected.
skip_n_lines can be used to read nth line relative to file position.
After this read the next read is at the beginning of the next line.
Also the routine errornum will return 6 (EOF_ERROR) if an EOF error occurred.
The routine returns EOL if reading past the end of line,
also the routine errornum will return 9 (EOL_ERROR) if an EOl error occurred.
.e.g
wd = rwl_file(A,1,0,0,0) - gives first word first line
wd = rwl_file(A,1,0,2,-1) - gives first word penultimate line
.EF
===========================================================
=============================================================
.BF
dspopen()
.(x
dspopen
.)x 
.FD
dspopen("/dev/dsp1")
returns a file handle to the dsp device.
On Linix system you may need to load kernal modules
e.g. install snd-pcm-oss via mod probe
sudo modprobe snd-pcm-oss
The kernel would need to be configured to include/generate the approriate sound device
drivers.

.EF
=============================================================
.BF
mixeropen()
.(x
mixeropen
.)x 
.FD
 mixfd = mixeropen("/dev/mixer1")


.EF
=============================================================
.BF
record_audio_buffer()
.(x
recordaudiobuffer
.)x 
.FD
record_audio_buffer(sbn,n_samples)

records into signal buffer obtained previously with createSignalBuffer
for n_samples.
The recording parameters are set previously with routine setrecordparams.


.EF
=============================================================
.BF
set_record_params()
.(x
setrecordparams
.)x 
.FD
set_record_params (dspfd , mixerfd, Freq, num_channels, mic_amp_cfg)
 The user will have already opened the recording device typically /dev/dsp1 and
 dspfd will be the file descriptor, similarly /dev/mixer1 -- mixerfd.
 The sampling frequency is supplied (e.g. 16000 Hz) and the number of recording channels
 (mono 1 , stereo 2). The mic_amp_cfg is the configuration for the microphone gain
 (0x5a5a is the default -- see sound library documentation).


.EF
=============================================================
.BF
ceil()
.(x
ceil
.)x 
.FD
ceil(A)
rounds a smallest integer value not less than arg value  
ceil(0.5) is 1.0 ceil (-0.5) is 0.0.



.EF
=============================================================
.BF
round()
.(x
round
.)x 
.FD
round(A)
rounds a floating point number delivers nearest integer value (away from zero) 
(see rint,ceil,floor,trunc)

.EF
=============================================================
.BF
Fround()
.(x
Fround
.)x 
.FD
Fround(A,n)
rounds a floating point number to n decimal places delivers result (see Round)


.EF
=============================================================
.BF
Sel()
.(x
Sel
.)x 
.FD
Sel(A,condition,val,{1},{justfirst})
compares array values  using "<,>,==,,!=,>=,<=" operations with value
    delivers an integer array which contains indices - where the
    operation was TRUE - else first element is -1 for no valid comparison
optionally delivers integer array where elements are 0 or 1
depending on TRUE/FALSE of element value comparison
If you need just the first element/index where the condition was true
set the final optional arg (justfirst) to one,
the default is to work through the vector.
(see Cmp)
.EF
=============================================================
.BF
SelVi()
.(x
SelVi
.)x 
.FD
SelVi(Array,Vec)
uses indices in Vec to build a subset vector from Array
.EF
=============================================================



.BF
Stats()
.(x
Stats
.)x 
.FD
S=Stats(A,{cond,break_number,cond2,break_number2})
The following statistics are computed for array A and returned to float array S
the sum [0],mean [1],sum of squares [2],variance [3], standard deviation [4],
min value [5] and maximum value [6] and index of min [7]   and max value [8]  and the number of values [9],
satisfying the conditions.

If cond is set ("<,>,==,,!=,>=,<=") then all elements passing that condition relative
to the break_number are used.
e.g.
S=Stats(F,">",0)
all elements of F greater than zero are used to compute sum, mean, ...

S=Stats(F,">",0,"<",max)
all elements of F in the range greater than zero and less than max are used to compute the summary statistics.


.EF
=============================================================
.BF
Sum()
.(x
Sum
.)x 
.FD
a=Sum(A)
returns sum of vector A - result is double if input vector was floating point
otherwise an integer vector is returned
for all integer types (guard against overflow)
a subset can be summed
b= Sum(A[0:9])  - first 10 values
c= Sum(A[2:8:2])  - sum the  values of elements 2,4,6,8
if A is array of Pan result is a Pan (arbitary precision number).
.EF
=============================================================
.BF
ColSum()
.(x
ColSum
.)x 
.FD
V=ColSum(A)
returns array V - containing the sum of the columns of a 2D array.
dimensions [1][n_of_cols]
V->redimn() - would redimension to vector

.EF
=============================================================
BF
RowSum()
.(x
RowSum
.)x 
.FD
V=RowSum(A)
returns array V - containing the sum of the columns of a 2D array.
dimensions [num_of_rows][1]
V->redimn() - would redimension to vector

.EF
=============================================================

.BF
Rms()
.(x
Rms
.)x 
.FD
a=Rms(A)
returns rootmeansquare of vector A - result is double
a subset can be summed
b= Rms(A[0:9])  - first 10 values
c= Rms(A[2:8:2])  - rms the  values of elements 2,4,6,8
if A is a matrix (2D) the Rms of each column is found
result is a vector of the rms for each column

.EF
=============================================================
.BF
Ave(),Mean(),
.(x
Mean
.)x 
.FD
a=Mean(A)
returns mean of vector A - result is double
a subset can be summed
b= Mean(A[0:9])  - first 10 values
c= mean(A[2:8:2])  - rms the  values of elements 2,4,6,8
if A is a matrix (2D) the Mean of each column is found
result is a vector of the Means for each column



.EF
=============================================================
.BF
save_image()
.(x
saveimage
.)x 
.FD
a=save_image(wid,fname)
The image in the clip region of window wid is saved to file fname.


.EF
=============================================================
.BF
selwin()
.(x
selwin
.)x 
.FD

sel_win(window_title)
selects as current window for graphics using window title
returns window number if successful. Error return is -1.
e.g
A=sel_win("A_Window")

.EF
=============================================================
.BF
selwid()
.(x
selwid
.)x 
.FD
sel_wid(wid)
selects as current window for graphics 



.EF
=============================================================
.BF
select_box()
.(x
selectbox
.)x 
.FD
select_box(&X[0])
allows the user to rubber_band area within screen and obtain area coordinates 

.EF
=============================================================
.BF
select_clip()
.(x
selectclip
.)x 
.FD


wid=select_clip(&X[0])
allows the user to rubber_band area within window and 
obtain area coordinates relative to window in array X.
returns wid or -1 if area not within window.


.EF
=============================================================
.BF
selectreal()
.(x
selectreal
.)x 
.FD
RS=select_real(wid)
allows the user to rubber_band area within window wid 
obtain real coordinates relative to
window real scales in array RS - first element is window wid -1 if invalid 


.EF
=============================================================
.BF
send_message()
.(x
sendmessage
.)x 

.FD
send_message(n,msg)
sends a message ( string ) to process number n.
Alternatively n may be the window title of the 
process.


.EF
=============================================================
.BF
slower()
.(x
slower
.)x 
.FD
slower(string,[si=0],[nc=-1])
returns string in lower case
slower(str,1,3)
 would change chars @ positions [1][2][3] to lower case 

.EF
=============================================================
.BF
supper()
.(x
supper
.)x 
.FD
supper(string)
returns string in upper case
supper(str,1,3)
 would change chars @ positions [1][2][3] in the string  to upper case. 

.EF
=============================================================
.BF
setpen()
.(x
setpen
.)x 
.FD
setpen(wid,color,width)
or setpen
sets pen of the window wid to color and width.
default black, width 1.
e.g.
setpen(w1,"green",2)
w_set_bkg(w1,"red") will set background

.EF
=============================================================
.BF
w_setbkg()
.(x
wsetbkg
.)x 
.FD
w_setbkg(wid,color)
w_setbkg(w1,"red") will set background color to red, using the default color map
w_setbkg(w1,2) has the same effect.

.EF
=============================================================
.BF
setpenpos()
.(x
setpenpos
.)x 
.FD
setpenpos(wid,r,c,f)

sets pen position of the window wid to 
if f = 1 then use current font to set
to r row and c column
otherwise r and c are x and y pixel position within window.
e.g.
setpen(w1,0,0,1)



.EF
=============================================================
.BF
setfont()
.(x
setfont
.)x 
.FD
setfont(font_name,size)

sets current font and size.
e.g.
setfont("Times-Roman",12)
To find out if rotated fonts are loaded
xlsfonts | grep rot
and can load them via
xset fp+ /home/mark/gasp-CARBON/fonts

.EF
=============================================================
.BF
w_scroll()
.(x
wscroll
.)x 
.FD
w_scroll(w,dir,nofpixs)
scrolls window image left -1,right 1,up 2,down -2, nofpixs

.EF
=============================================================
.BF
scrollClip()
.(x
wscroll
.)x 
.FD
sWo(won,@scrollclip,dir,nofpixs)
scrolls wo clip  image left -1,right 1,up 2,down -2, by nofpixs
sWo(picwo,@scrollclip,DOWN_,10)

.EF
=============================================================
.BF
w_set_coor()
.(x
wsetcoor
.)x 
.FD
w_set_coor(w,X,Y)
set orgin of window coordinates to X,Y

.EF
=============================================================
.BF
w_set_rotate()
.(x
wsetrotate
.)x 
.FD
w_set_rotate(w,angle)
set rotation of window coordinates by angle(degrees)


.EF
=============================================================
.BF
reverse()
.(x
reverse
.)x 
.FD
V->reverse()
reverses vector -- operation in place on vector V


.EF
=============================================================
.BF
bitrev()
.(x
bitrev
.)x 
.FD
bitrev(n, m)

 bit reverses a number n --- m power of 2
 e.g. 1,3    001 ---> 100   = 4
      3,3    011 ---> 110   = 5
  




.EF
=============================================================
.BF
set_sr()
.(x
setsr
.)x 
.FD
set_sr(wid,sample_1,{sample_2})

sets the select region of a signal buffer associated with window wid 
to start at sample_1  and to end at sample_2.
If sample_2 is left unset or set to -1 then
sample_2 is set to the end of the buffer.

.EF
=============================================================
.BF
set_sr_times()
.(x
setsrtimes
.)x 
.FD
set_sr_times(wid,time_1,time_2)
sets the select region of a signal buffer associated with window wid 
to start at time_1  and to end at time_2.


.EF
=============================================================
.BF
ferror()
.(x
ferror
.)x 
.FD
ferror(File_handle)
will return number of  file io error for file_handle (returned via o_file).
returns 0 if no error has occured.
.nf
File open error       10
EOF		      6
EOL		      9
.fi

.EF
=============================================================
.BF
feof,()
.(x
feof
.)x 
.FD
feof(File_handle)
will return true if EOF error has occurred for that file stream.

.nf
.fi

.EF
=============================================================
.BF
Rescape()
.(x
Rescape
.)x 
.FD
Rescape(vec[],ec,eval[],reval[])
 replaces escaped characters escape char and the following values in array with 
new value - the pairs of escaped values and their replacement values are given
in the arrays eval,reval. The value of escape character  is ec.
Works on uchar and char arrays. The new array of possibly different size is returned.
e.g.
nvec = rescape(vec,0x81,eval,reval)

.EF
=============================================================
.BF
errornum()
.(x
errornum
.)x 
.FD
errornum()
will return number of latest syntax or file io error.
returns 0 if no error has occured.

.EF
=============================================================
.BF
seterrornum()
.(x
seterrornum
.)x 
.FD
setErrorNum(n)
sets the last error to be n.

.EF
=============================================================
.BF
lasterror(), errorNum()
.(x
lasterror
.)x 
.FD
lastError()
returns the last error.

.EF
=============================================================
.BF
errorName()
.(x
errorname
.)x 
.FD
errorName()
will return last error as a name
and errorName(n)
return  error n  as a name.

.EF
=============================================================

.BF
Saw,Triangle()
.(x
Saw,Triangle
.)x 
.FD
Saw(A, {rf})
Triangle(A, {rf})
returns value for a saw-tooth(triangular) waveform where A is in radians. 
A can be a vector.
The parameter rf [0.0 - 1.0] controls the 'attack' - rf = 0.5 is equivalent to a triangular
wave. rf = 0.0 is the fastest rise time, rf = 1.0 is the slowest.


.EF
=============================================================
.BF
Sin()
.(x
Sin
.)x 
.FD
Sin(a)
returns sine where a is in radians. 
If a is a vector then a vector of the sines of its elements is returned.


.EF
=============================================================
.BF
Sqrt()
.(x
sqrt
.)x 
.FD
sqrt(a)
returns square root. 
If a is a vector then vector of the square roots of its elements is returned.




.EF
=============================================================
.BF
sp_script()
.(x
spscript
.)x 
.FD
sp_script(script_name)

A ASL process is initiated which interprets script script_name. 
A number of scripts can run concurrently ( the number is system dependent).
The graphic window manager deals with their request(instructions) in a round_robin
fashion. 
returns pid of ASL process - 
this can be used to send messages from one
ASL process to another.


.EF
=============================================================
.BF
set_alias()
.(x
setalias
.)x 
.FD
set_alias(name,path)
sets up an alias for a path - or an alias for any string

.EF
=============================================================
.BF
set_uwat()
.(x
setuwat
.)x 
.FD
set_uwat(wid,on_off,octal)
sets bit in octal word representing the user controlled window attributes.
e.g. whether the axes are shown, title ,cursors.
	axes		20
(see appendix on window attributes)

.EF
=============================================================
.BF
set_swat()
.(x
setswat
.)x 
.FD
set_swat(wid,on_off,octal)
sets bit octal word representing the system controlled window attributes.
e.g. whether the window is currently buried,acting as a terminal etc.
(see appendix on window attributes)


.EF
=============================================================
.BF
splice()
.(x
splice
.)x 
.FD
splice(wid)

The cut/paste buffer is spliced into  the buffer associated with window wid at the 
start of the select region for that window.
returns the buffer size in samples.

.EF
=============================================================
.BF
vsplice()
.(x
vsplice
.)x 
.FD
newvec=vsplice(vec1,vec2, index)

  Splices one vector into another at the specified index.
  If index is not specified the operation is to append the second vector;
  A new vector is returned. ( but V=splice(V,V2,index) is allowed).
  If index is greated than current size of vec1 then vec1 is resized
  to the index before the splice/append occurs.
  

.EF
=============================================================
.BF
regex()
.(x
regex
.)x 
.FD
posn=regex(haystack_str,needle_regex_pat)
searches for pattern in string returns an array of start offsets for that pattern
and the end offsets plus 1 i.e. the offset after the end of the pattern.
returns [-1,-1] if pattern not found.

.EF
=============================================================
.BF
scat()
.(x
scat
.)x 
.FD
ws=scat(w1,w2,{w3,w4,...})
concatenates w2 to w1 (or more args) returns the result

.EF
=============================================================
.BF
nsc()
.(x
nsc
.)x 
.FD
ws=nsc(n,w1)
self concatenates w1 n times and returns the result

.EF
=============================================================
.BF
scut()
.(x
scut
.)x 
.FD
ws=scut(w1,nc)
cuts n chars from head or tail ( if n is negative) of the string w1,
and returns result to string ws.


.EF
=============================================================
.BF
str_ncat()
.(x
strncat
.)x 
.FD
str_ncat(w1,n)
returns n characters of sivar w1 

.EF
=============================================================
.BF
scpy()
.(x
scpy
.)x 
.FD
scpy(&M[0],&T[0],{n})
returns len of string copied, (from second to first parameter) 
used for char arrays 
but can also copy the string contained by an sivar
the maximum number of characters to be copied can also be set.
e.g.
scpy(&M[0],&w1) or  scpy(&w1,&M[0]) 
.br
scpy(&M[1],&T[2],4)


.EF
=============================================================
.BF
scmp()
.(x
scmp
.)x 
.FD
scmp(w1,w2,{n},{case},{difference})
string compare of w1,w2 variables returns 1 if same 0 if different.
will compare up to n characters default all. 
If case set to zero a case independent match is made.
If difference set to 1 - return is as C routine strcmp.
If n is zero all the string is compared, else the first n characters.
if n less than zero the tails are compared for n elements.
Use VMF variation if S is a array of strings and you want the operation to be applied to all elements 
rv=S.scmp("and")
would return into a integer vector rv the results of a scmp operation on all elements (strings) of the
svar vector. 
(see strcmp)

.EF
=============================================================
.BF
strcmp,strdiff()
.(x
strcmp
.)x 
.FD
diff= strcmp(s1,s2)
diff= strdiff(s1,s2)
 will compare strings via the C routine strcmp. 
 It returns an integer less than, equal to, or greater than
       zero if s1 is found, respectively, to be less than, to match, or be greater than s2.

.EF
=============================================================
.BF
scnt,scntascii()
.(x
scnt
.)x 
.FD
scnt(w1)
tallys up the ascii values of the string.


.EF
=============================================================
.BF
ssub()
.(x
ssub
.)x 
.FD
ssub(w1,w2,w3,{dir})
 
substitutes string w3 into w1 for  first occurrence of w2 returns the result.
if dir 1 (default) starts at left, -1 from right, dir = 0 global substitute.
if w3 set to "" (i.e. NULL)  delete operation (deletes occurence of w2).
if dir > 1 then that many substitutions are performed from the left if possible.

.EF
=============================================================
.BF
ssubrgx()
.(x
ssubrgx
.)x 
.FD
ssubrgx(w1,w2,w3,{dir})
 
substitutes string w3 into w1 for  first occurrence of regex pattern w2
and returns the result.
if dir 1 (default) starts at left, -1 from right, dir = 0 global substitute.
if w3 set to "" (i.e. NULL)  delete operation (deletes occurence of w2).
if dir > 1 then that many substitutions are performed from the left if possible.

.EF
=============================================================
.BF
spat()
.(x
spat
.)x 
.FD
spat(w1,w2,{posn,dir, [match[2]})

matches string w2 in w1 returns the characters before or after the match (default before)
depending on optional parameters (posn, dir).
if posn = 1 rest of characters from right of match
posn = 0 including match string, posn = -1 before match, (default -1)
If dir = 1 search starts at the left, -1 from right. (default 1)
If the variables match vector supplied
then match[0] is one if there was a match
and how many characters are remaining is in match[1].
also spat will return the string "" if no match
use match and charrem to determine the result of pattern search.
e.g.
a is 4.0,0.5,0.7  b is ,
c = spat(a,b)  : c is 4.0
c = spat(a,b,1)   : c is 0.5,0.7
c = spat(a,b,-1)  : c is 4.0
spat(a,b,0)   : c is ,0.5,0.7
c = spat(a,b,1,-1) : c is 0.7
c = spat(a,b,-1,-1) : c is 4.0,0.5 
c = spat(a,b,0,-1) : c is ,0.7

For regex patterns use
cresult =spatrgx(w1,w2,{posn,dir, [match[2] })
or
regex " pma=regex(w1,w2) "
where w2 is a regex pattern and pma is array of start and end indices
for that pattern if found,
if first entry in pma is [-1,-1] then the pattern was not found. 


.EF
=============================================================
.BF
slen,str_len()
.(x
slen,strlen
.)x 
.FD
slen(w1)
returns character length of parameter

.EF
=============================================================
.BF
srev,str_rev()
.(x
srev,strrev
.)x 
.FD
srev(w1)
reverses string





.EF
=============================================================

.BF
Trim()
.(x
Trim
.)x 
.FD
Trim(S)
Trims a string variable (or array of strings)

S->Trim(nc) - trims characters from head or tail of string

S[a:b]->Trim(-4)
would trim four chars from end of  a range of an array of strings - where S is an array
S->Trim(4)
would trim four chars from the head of  a range of an array of strings - where S is an array 
(see prune)
.EF
=============================================================
BF
Prune
.(x
Prune
.)x 
.FD
Prune(S)
Prunes a string variable (or array of strings) to a specified length

S->Prune(length) - trims characters from head or tail of string until a specified length
 no action if stem already less than of equal to required length

S[a:b]->Prune(-4)
would prune  from tail of  a range of an array of strings - where S is an array
S->Prune(4)
would prune from head of string until required length

.EF
=============================================================

.BF
split()
.(x
split
.)x 
.FD
A=split(string,{stringdel})
splits a string into a list of sub-strings using a string delimiter (default white space)
it returns svar array type - each element contains a sub-string
e.g.
Svar A= split("once upon a time")
A[0] contains "once"
A[1] contains "upon"
...


.EF
=============================================================
.BF
sscan,str_scan()
.(x
sscan,strscan
.)x 
.FD
sscan(text,fmt,&var1,&var2,...)
will read a word out of text buffer into an variable.
The scanf fmt string is used to convert into variables of the specified type;
e.g.
float f
int d
str s
nargs=sscan("1.2 3 normal",'%f %d',&f,&d,s)
note a single quoted string is used to prevent interpretation of % if you
use double quoted string the % must be escaped with backslash
nargs=sscan("1.2 3","\%f \%d",&f,&d)
returns number of args interpreted.
If the variable is a string then just the variable name is used.
The suppression format %*  can be used  to skip over individual words
nargs=sscan("1 2 3 ",'%d %* %d',&i,&k)
k would be set to 3.


.EF
=============================================================
.BF
sstr,(strstr)()
.(x
sstr
.)x 
.FD
iv=sstr(haystack_str,needle_str,[ignore_case=0],[all=0])
:- finds needle_str in haystack_str returns index to first occurence or all.
returns integer vector of indices -- if not found iv[0] == -1,
else iv contains position indexes of needle_str.
.EF
=============================================================

.BF
scin()
.(x
scin
.)x 
.FD
scin(str1,str2,[all=0]) : count occurrence of any char from str2 
               which is in str1  default return on first occurrence option count all=1");
.EF
=============================================================


.BF
getrgb()
.(x
getRGB
.)x 
.FD
rgb_v=getRGB(index)
rgb_v=getRGB(color_name)
returns r,g,b values (0.0 - 1.0) into float vector length 3 -- for an index (or a color name)

.EF
=============================================================
.BF
getrgbdec()
.(x
GetRGBdec
.)x 
.FD
rgb_v=GetRGBdec(index)
rgb_v=GetRGBdec(color_name)
returns r,g,b values 0-255,0-255,0-255 into int vector length 3 -- for an index (or a color name)

.EF
=============================================================
.BF
getrgbhex()
.(x
GetRGBhex
.)x 
.FD
rgb_v=GetRGBhex(index)
rgb_v=GetRGBhex(color_name)
returns r,g,b values as hex string 


.EF
=============================================================

.BF
rgbToColorIndex()
.(xdefault color map used  
rgbToColorIndex
.)x 
.FD

Given an vector of RGB values (unit) and start and finish index into the global color
map C_map - find the nearest color (C_map index) for each rgb value
and return that as an array (uint)

e.g.  CMSPIX=rgbToColorIndex(AVESPIX,cmi,cmi+nc)

 should have option to supply local color map

 CMSPIX=rgbToColorIndex(AVESPIX,CMAP, [cmi =0], [cmi_end = (CMAP.size -1)])


.EF
=============================================================
.BF
rainbow()
.(x
rainbow
.)x 
.FD
rainbow -- default color map used  

.EF

=============================================================
.BF
setgsmap()
.(x
setgsmap
.)x 
.FD
setgsmap(num_of_grey_levels, start_index)
Inserts a greyscale map into the Global color map starting at start_index

.EF
=============================================================

.BF
setrgbindexfromname()
.(x
Setrgbindexfromname
.)x 
.FD
setrgbindexfromname (index,"lilac")
looks up rgb from HTML table for color sets up color map index for that color (if found)


.EF
=============================================================
.BF
getColorIndexFromRGB()
.(x
getColorIndexFromRGB
.)x 
.FD
index=getColorIndexFromRGB(r,g,b)
returns color index that is closest to supplied r,g,b values

.EF
=============================================================
.BF
getColorIndexFromName()
.(x
getColorIndexFromName
.)x 
.FD
getColorIndexFromName(name_str)
if there is a match of name return color index else -1.
.EF
=============================================================
.BF
set_buf()
.(x
setbuf
.)x 
.FD
set_buf(wid,n)
sets signal buffer number associated with window wid


.EF
=============================================================
.BF
setdebug()
.(x
setdebug
.)x 
.FD
SetDebug(level,[cond1,cond2,...])
if level = -1 there is no error reporting, 0 important error messages.
Higher levels for expression parsing and function calling. 
If no errors and debug level is 0, (the default) the debug file is
removed on exit.

e.g.
setDebug(1,@keep,@pline,@filter,0)

tag value options are :-


step - cause the program to work line by line.

steponerror - cause the program to run until first error 
              when it enters step mode.

pline- prints each line as it is executed.

run - causes the program to run (default) logging errors
      until completion or failure.

prun - causes the program to run (default)
       logging errors until completion or failure,
       but also printing the debug messages.

trace -  shows internal function call sequence --
~trace - turns off tracing. 

filter - filter internal code via name , 0 no filter, 1 allow named, 2 reject named, 3 reject all

to set named functions or named code files to debug use
filterDebug and/or filterFileDebug
e.g
filterFuncDebug(ALLOW,"checkGlobalVar")
this would allow the filter option to accept debug from this function.
filterFuncDebug(REJECT,"checkGlobalVar")
this would allow the filter option to reject debug from this function.



This options are for primarily source code debugging, not for ASL debugging. 


By default the debug output goes to the .GASP/WORK/Debug/ directory
either the file 'idb' for the initial interpreter, or
'xdb' for the 'compiled' version.
(e.g. "asl -c foo.asl"   will produce a 'compiled' version foo)     


While running the debug file name is .debug_progname.pid this will be changed
to .debug_progname on exit, unless 'pid' if specified as one of the conditions.


For work with xgs
If the journal switch in the devices 
menu is ON then the debug stream goes to journal file in the GS 
directory.
(see name_debug)






.EF
=============================================================
.BF
filterFuncDebug
.(x
filterFuncDebug
.)x 
.FD
filterFuncDebug(ALLOW_,"foo","checkprocfunc", ...)
Would pass debug statements from internal code module foo to debug stream.
the filter can be set to
ALLOWALL_
REJECT_
and REJECTALL_

.EF
=============================================================
.BF
filterFileDebug
.(x
filterFileDebug
.)x 
.FD
filterFileDebug(ALLOW_,"args_parse", ...)
Would pass debug statements from internal code file(s) args_parse*cpp  to debug stream.
the filter can be set to
ALLOWALL_
REJECT_
and REJECTALL_

.EF
=============================================================

.BF
namedebug()
.(x
namedebug
.)x 
.FD
name_debug(name,threshold)
For debugging asl scripts,
name can be 
ARG
VAR
SI
PROC
EXP
DECLARE
for debugging various parts of the interpreter
if threshold is lower than or equal to the debug level 
all debug messages appear


.EF
=============================================================
.BF
geterrors()
.(x
geterrors
.)x 
.FD
err=geterrors()
returns the number of errors so far to a two element array
err[0] = N_error ---- number of errors occurred in processing functions
err[1] = N_cerror ---- number of code errors occurred in script  user (and parsing errors)

.EF
=============================================================
.BF
setmaxcodeerrors()
.(x
setmaxcodeerrors()
.)x 
.FD
setmaxcodeerrors(N)
set the number of detected code errors allowed before exit
set to -1 - nolimit.

.EF
=============================================================
.BF
setmaxicerrors()
.(x
setmaxICerrors()
.)x 
.FD
setmaxICerrors(N)
set the number of detected internediate code errors allowed before exit
set to -1 - nolimit.

.EF
=============================================================
.BF
getcodeln()
.(x
getcodeln
.)x 
.FD
line=getcodeln(lnum, includenum)
returns the src line for the nth included file
e.g.
line = getcodeln(10,0)
would get the 10th of the first (main) script.
lines are from 1 to n.
includes are from 0 (main) 1, first included file ...nth included file
.EF
=============================================================
.BF
set_menu_value()
.(x
setmenuvalue
.)x 
.FD
set_menu_value("menu_file","label",M_value)

The function set_menu_value searches the menu by label name and sets the menu item value,
to M_value.

(see also w_menu).


.EF
=============================================================
.BF
setwrs()
.(x
setwrs
.)x 
.FD
set_w_rs(wid,s_nu,value)
sets real scale value for window wid.

   s_nu    scale
   0       x_min
   1       y_min
   2       x_max
   3       y_max
or all scales can be set at once with the alternative form
set_w_rs(wid,x,y,X,Y)

.EF
=============================================================
.BF
showcurs()
.(x
showcurs
.)x 
.FD
show_curs(on,{sx,sy,{"cursor_name"}})

shows cursor at current position or at sx sy. 
The on parameter turns the mouse cursor on or off.
A different cursor can be loaded.
Cursor images reside in the FONTS directory.

.EF
=============================================================
.BF
fseek()
.(x
fseek,sfile
.)x 
.FD
fseek(A,n_bytes,end)

seeks n_bytes from position in file. 
end 0 start of file
end 1 current position
end 2 end of file
returns file position in bytes after seek.
fseek(A,0,1) serves as ftell function - current location in file
returns -1 if end of file detected.


.EF
=============================================================
.BF
ftell()
.(x
ftell
.)x 
.FD
where=ftell(A)
returns file position in file referenced by file handle A.



.EF
=============================================================
.BF
srv()
.(x
srv
.)x 
.FD
sr_v(wid,&f[0],n)
converts  upto a maximum of n values of the select region of the 
signal buffer associated with window wid into float array f( see v_sr).
if n is set to -1 , the entire select region is converted.
returns the number of elements converted.



.EF
=============================================================
.BF
invertsr()
.(x
invertsr
.)x 
.FD
invert_sr(wid)
will invert the select region of the buffer
(see_also clip_sr,mul_sr,agc_sr,clip_sr,cclip_sr)


.EF
=============================================================
.BF
table_menu()
.(x
tablemenu
.)x 
.FD
table_menu("menu_file",{mx,my})

This menu routine allows the user to
fill in table or parameter values for each menu item and then set them and return.
The functions rd_menu or get_menu_value can be used to obtain any menu item value.
By default table_menu places a menu at the current mouse location,
otherwise the user can set the menu position using the optional mx,my parameters.


.EF
=============================================================
.BF
Text()
.(x
Text
.)x
.FD
Text(id,string,x,y,{p,dir,pos})
places string at coordinates x,y in direction dir for 
for window object id.
If p is 1 the scales of the clip region are
set to 0.0 and 1.0. If dir is 90 vertical text is produced.
If pos = 1 then the string is centered at x,y.
If pos = 2 then the string is ends at x,y.
Otherwise the string starts at x,y.

if p is set to TEXT_AXIS_BOTTOM (3) the text is placed relative to the bottom axis of the clip 
area - x is a fraction 0 left corner 1 right corner and y is fraction of font size
positive above the axis, negative below the axis

if p is set to TEXT_AXIS_TOP (5) the text is placed relative to the upper axis of the clip 
area - x is a fraction 0 left corner 1 right corner and y is fraction of font size
positive outside the graph, negative inside the graph

if p is set TEXT_AXIS_LEFT (4) the text is placed relative to the left axis/border of the clip region. 
if p is set TEXT_AXIS_RIGHT (6) the text is placed relative to the right axis/border of the clip region. 

.EF
=============================================================
.BF
AxLabel()
.(x
AxLabel
.)x
.FD
AxLabel(wo_id,axis,string,fp, sp,{hue, pos, dir})
places string at alongside axis at fractional value fp (axis is scales 0 to 1) and offset from the axis by font spacing sp,
for window object wo_id.
If pos = 1 then the string is centered at fp.
If pos = 2 then the string is ends at fp.
Otherwise the string starts at fp.

if the font spacing is negative the text is inside of the clip drawing area else it is outside.

bottom axis  1
left axis  2
top axis  3
right axis  4

e.g
AxLabel(wwo,1, "TIME", 0.5, 2,) 
would place the text TIME  below the bottom axis by twice the font height at the midway value on the
bottom axis scale. 

.EF
=============================================================
.BF
AxText()
.(x
AxText
.)x
.FD
AxText(wo_id,axis,string, rp, sp,{hue, dir, pos})
places string at alongside axis at position governed by the real scale value rp 
and offset from the axis by font spacing sp,
for window object wo_id.
If pos = 1 then the string is centered at fp.
If pos = 2 then the string is ends at fp.
Otherwise the string starts at fp.

if the font spacing is negative the text is inside of the clip drawing area else it is outside.

bottom axis  1
left axis  2
top axis  3
right axis  4

e.g
AxText(wwo,1, "Start", 40.5, 2,) 
would place the text "Start"  below the bottom axis by twice the font height 
at a position of 40.5  value on the bottom axis scale. 



.EF
=============================================================
.BF
ticks()
.(x
ticks
.)x 
.FD
ticks(wid,axis,s,S,ds,tl)

places tick_marks at interval ds starting at s on axis number

bottom axis 1
left   axis 2
top    axis 3
right  axis 4

tick marks of length tl where tl is a fraction of the
perpendicular axis i.e. tl = 1.0 will be a grid line
tl = 0.05 will give a "normal size tick mark"



.EF
=============================================================
.BF
transpose()
.(x
transpose
.)x
.FD
transpose(M)
forms the transpose of a 2 dimension matrix (interchanges row and columns)


.EF
=============================================================
.BF
Redimn()
.(x
Redimn
.)x
.FD
Redimn(M,{n,m,p,..})
M->Redimn(n,m)
redimensions a multidimension array.
e.g. float M[20];

 M->Redimn(5,4)

would make a 20 element vector into a two dimensional array of 5 rows and 4 columns.

If no dimensions are specfied a single dimension array is formed,
otherwise the product of the dimension must equal the current number of elements
in the multidimension array M.
Returns number of new dimensions on success else 0 if failure (if so the original array bounds
are left as before).


.EF
=============================================================
.BF
Resize()
.(x
Resize
.)x
.FD
Resize(M,{n,m,p,..})
resizes a multidimension array.
If no dimensions are specfied a single dimension array is formed,
Will force the array M to have new dimensions of n x m x p, ...
So the array will be resized as necessary,
e.g. resize(V,30)
would result in a single dimension array of size 30 -- regardless of the previous size of V
e.g. resize(V,4,5)
would result in a two dimension array of V[4][5] -- regardless of the previous size and dimensions of V
a realloc is performed 
if the new size is greater than or equal to the old size previous contents are still present,
else  the first ( new size) elements are left. 


.EF
=============================================================
.BF
Shuffle()
.(x
Shuffle
.)x 
.FD
Shuffle(A,{ns,n})
Performs an in place shuffle of array.
The default number of shuffles (swopping two random elements) is equal to the
number of elements of the array.


.EF
=============================================================
.BF
Trunc()
.(x
Trunc
.)x 
.FD
Trunc(A)
truncates a floating point number delivers nearest integer value not larger in absolute value.

.EF
=============================================================
.BF
Typeof()
.(x
Typeof
.)x 
.FD
Typeof(V)
typeof - returns the type of the variable V as a string FLOAT,INT,...


.EF
=============================================================
.BF
Abs()
.(x
Abs
.)x 
.FD
Abs(A)
truncates a floating point number delivers absolute integer result.
if A is a vector then operation occurs on all elements of the vector.
e.g. V=Abs(A)  - V is a new vector of type integer of converted results.
(see Fabs)

.EF
=============================================================
.BF
Fabs()
.(x
Fabs
.)x 
.FD
Fabs(A)
delivers magnitude (absolute) result



.EF
=============================================================
.BF
Vfree()
.(x
Vfree,Freev
.)x 
.FD
vfree(A)
releases memory previously allocated to the vector A.

.EF
=============================================================

.BF
delete()
.(x
delete
.)x 
.FD
delete(A)
variable A  and its memory are deleted --
the name can then be reused to create new variable. 



.EF
=============================================================
.BF
lidelete()
.(x
lidelete
.)x 
.FD
lidelete(item_posn)
the list item @ specified position is deleted,
0 is start, -1 can be used to indicated last item.



.EF
=============================================================
.BF
vrealloc()
.(x
vrealloc
.)x 
.FD
vrealloc (&A[0],n)
reallocs memory previously allocated to the vector A if n larger than previous
new memory is initiallized to zero.
returns new size (zero is failure)
If vector/array is declared dynamic e.g. A[50+] 
initial size 50 will be dynamically extended avoiding need for v_realloc for
extending vector. 


.EF
=============================================================
.BF
vzoom,v_zoom()
.(x
vzoom
.)x 

.FD
R=vzoom(A,newsz,{"spline"})
linearly interpolates vector  A to newsz, return result to new vector R 
optionally a cubic spline interpolation can be used.

.EF
=============================================================
.BF
vrange()
.(x
vrange
.)x 

.FD
vrange(A,floor,ceil,newrange_lower,newrange_upper)
rescales values in vector A that are equal to floor and between or equal to ceil to a
a different range (using linear extrapolation) that is from  newrange_lower to newrange_upper.
Any value in the original vector below floor is set to newrange_lower any value above ceil in the original
vector is set to newrange_upper. 
If newrange_upper is not specified then zero is assummed for newrange_lower
and the third parameter is taken  as newrange_upper.
The function returns a new vector (float, double) with the transformed values.


.EF
=============================================================
.BF
range,subscript()
.(x
range,subscript
.)x 

.FD
A=vector[start:end:step]
vector A contains a subrange of vector - start element through and including end element, optionally using a step size.
B=CV[10:20:]
B contains the elements(11) 10 thru 20 of vector CV.

B=CV[10:20:2]
B contains the elements 10,12,14,16,18,20 of vector CV.
The last element of a vector is assigned the index -1 so -
B=CV[-10:-1:]
B contains the last ten elements of vector CV.




.EF
=============================================================
.BF
vs_a()
.(x
vsa
.)x 
.FD
vs_a ( &A[0],alpha,&B[0],N)
adds scalar to N locations of float array A result in array B.

.EF
=============================================================
.BF
vsm()
.(x
vsm
.)x 
.FD
vsm (&A[0],alpha,&B[0],N, {step_1,step_2})
multiplies  scalar to N locations of float array A result in array B.
step_1, step_2 are stride variables for indexing through arrays A,B.
default stride is 1.


.EF
=============================================================
.BF
vthres()
.(x
vthres
.)x 
.FD
vthres  (&A[0],alpha,&B[0],N,{upper_limit,lower_limit}, {step_1,step_2})
limits    N locations of float array A to upper limit
if value is above  the threshold alpha. 
Otherwise the lower limit is set.
Results in array B.
Upper limit default 1.0, lower limit default 0.0.
step_1, step_2 are stride variables for indexing through arrays A,B.
default stride is 1.


.EF
=============================================================
.BF
vvcopy()
.(x
vvcopy
.)x 
.FD
vvcopy(A,B,n,{condition,cond_value},{stepA,stepB},{offsetA,offsetB})
copies n locations of array B to corresponding locations in array A.
s1 and s2 are step sizes default is 1.
Also the copy can be conditional
(condition set to GT_,LT_,GTE_,LTE_,EQ_,NEQ_,ALWAYS_)
or (condition set to ">","<",">=","<=","!=")
for a comparison of array value and cond_value,
for the copy operation
to take place, i.e. the array data can be filtered via a condition.


Additionally the steps and offsets into the arrays can be set
e.g.
vvcopy(A,B,n,GTE_,0,1,2,5,6);
where the access starts at element 6 of B and steps by two.
the first successful compare (number GTE to 0)  goes into element 5 of vector A.
and the next into element 6, ...

There is an internal check to prevent accessing or writing beyond
the arrays, but the success of the operation requires programming
inspection with respect to array size.
Returns number of values copied into array A.
.EF
=============================================================.BF
()
.BF
vvcomp()
.(x
vvcomp
.)x 
.FD
R=vv_comp(A,B,{n})
compares two arrays, upto n points
and returns vector R where
R[0] sum of differences,
R[1] sum of squares of differences
R[2] = 2.0 if all A gt B
R[2] = 1.0 if all A gt or eq B
R[2] = 0.0 if all A  eq B
R[2] = -1.0 if all A  eq or lt B
R[2] = -2.0 if all A   lt B
R[2] = -3.0 if some gt and eq and  lt B

R[3] first index location of smallest difference



.EF
=============================================================
.BF
vvdraw()
.(x
vvdraw
.)x 
.FD
vvdraw(wid,X,Y)
draws an xy plot in window wid of the x y values in the arrays X and Y.
( see v_draw)


.EF
=============================================================
.BF
vvm()
.(x
vvm
.)x 
.FD
vv_m(&A[0],&B[0],&C[0],n,{s1,s2,m})
multiplys n locations of float array A by corresponding locations in array B result in array C.
s1 and s2 are step sizes default is 1.
m is allows cycling through A via B m times where vector length of B is n (default m = 1).


.EF
=============================================================
.BF
Vdraw, DrawY()
.(x
Vdraw
.)x 
.FD
vdraw(woid,Y,{ymode,AScale,xmode,x0,x1})
 Draws a plot of the  y values in the array Y (can be subscripted array), 
in window object woid. Default mode ymode = 0 will  use existing window Y scales.
Autoscale mode (ymode = 1) is to autoscale (with AScale = 1.0) and set 
the window vertical scales to the minimum y value and maximum y value found in the
vector.
 Setting Ascale = 0.75  (ymode = 0) would scale the vertical scales so that 
the plot used 0.75 of the vertical space of the window.
If ymode = 2, then the lower y scale value is set to zero and the upper value is autoscaled.

 Default xmode = 0 is to set the window scale xmin to 0 and xmax to (n-1)
where n is the number of values in the array to show the complete vector.
 If xmode =1 and x0 and x1 are specified then
x0 is the x value for the first element in the array and
x1  is the x value for the last element and window xmin and xmax scales are set to
x0 and x1.
 If xmode =2 and x0 and x1 are specified then the existing window x scale is used,
the assumption is that values in the vector are linearly spaced so a sub-range can
be displayed via manipulation of the window object scales.



.EF
=============================================================
.BF
vpow()
.(x
vpow
.)x 
.FD
v_pow(&A[0],&B[0],&C[0],n)
computes A[i] to power B[i] for n locations  result in C[i].


.EF
=============================================================
.BF
v_sr()
.(x
vsr
.)x 
.FD
v_sr(wid,&f[0],n)
converts  n values of float array f into the select region of the 
signal buffer associated with window wid ( see sr_v).


.EF
=============================================================
.BF
vset()
.(x
vset
.)x 
.FD
v_set(&f[0],val,incr,n,{s1})
sets vector values
val is initial value, value is then incremented by incr to set n vector values.
s1 is the step index size default is 1.
v_set(&f[0],0.0,0.0,n) will clear the array.
v_set(&f[0],0.0,1.0,n) will set the values 
0.0 , 1.0, 2.0, 3.0 ...
v_set(&f[0],0.0,1.0,n,2) will set the values 
0.0 , 1.0, 2.0, 3.0 ... for every other element.
(see fgen,igen)



.EF
=============================================================
.BF
vprint()
.(x
vprint
.)x 
.FD
v_print(A,Y,{fmt},{record_length)
prints vector (which can be subscripted) to file specfied by file handle A  (see ofw)
the format can be specified by a string (e.g. "%d " for integer, "%f " for float values).
The record length (default number of items is 1) can be specified and a newline is written per record.
e.g.
v_print(A,S,"%d ")
v_print(A,Y[2;32],"%f ",4)


.EF
=============================================================
.BF
vread()
.(x
vread
.)x 
.FD
nir=vread(A,Y,n,{r_type})
reads vector of n values from file A (see o_file)
optionally converts from r_type to internal type of Y array.
The assumed r_type is float.
e.g.
nir=vread(A,Y,129,"short")
reads 129 shorts into float array Y.
returns number of items read. This will be a short count or zero when the end of file is reached.


.EF
=============================================================
.BF
vunique()
.(x
vunique
.)x 
.FD
sorts through vector (just INT for now) and
returns a  new vector of unique values.
(should use int,long word size for compare for float,double types).


.EF
=============================================================
.BF
mread()
.(x
mread
.)x 
.FD
nir=mread(A,M,nrows,ncols,frows,fcols,{start_frow=0},{start_fcol=0},(skip_frow=0})
reads matrix of nrows,ncols  from file A organized as frows,fcols.
Optionally index in by start_frow,  and each index into each row by start_fcol.
After reading row optionaly skip  by skip_frow.
The assumed file data type is the type of receiving matrix.


e.g.
uint M[]
nir=mread(A,M,512,512,4096,1024, 100, 50)
Treat the data file as 4096 rows and 1024 cols of uints.
Index to 100th row in file -- index to col 50 in each row.
Read 512 rows of 512 cols.
returns number of items read.
This will be a short count or zero when the end of file is reached.


.EF
=============================================================
.BF
vswab()
.(x
vswab
.)x 
.FD
v_swab(Y,n)
swaps the byte order of the array, short, int or float




.EF
=============================================================
.BF
wborder()
.(x
wborder
.)x 
.FD
w_border(wid)

draws a border round window wid. 

.EF
=============================================================
.BF
wclipborder()
.(x
wclipborder
.)x 
.FD
w_clip_border(wid)

draws a border round the clip region of window wid. 

.EF
=============================================================
.BF
wfile()
.(x
wfile
.)x 
.FD
w_file(A,"$p1 $p2")

writes the ascii respresentation of parameters p1,p2 into the file pointed to by A.
returns file position in bytes after the  write
if the parameter contains the string \n a carriage return line feed is
written to the file

.EF
=============================================================
.BF
writeline()
.(x
writeline
.)x 
.FD
writeline(A,var_line)

writes the string contained by var_line to the file handle A.
returns characters written - 0 if error;
It appends a '\n' ;


.EF
=============================================================
.BF
wdata,vwrite()
.(x
wdata,vwrite
.)x 
.FD
w_data(A,V,V2[a:b:c],a,...)

writes the vectors (which can be subscripted) into the file pointed to by file handle A.
returns number of items written
e.g wdata(A,F)
would write the entire vector F to file, 


The list of variables can include scalars.
A string constant e.g. w_data(A,"ABCD") is written as a sequence of chars.
(see rdata,wcdata)
.EF
=============================================================

.BF
wcdata,()
.(x
wcdata
.)x 
.FD
wc_data(datatype,A,V,V2[a:b:c],a,...)

converts and writes the vectors (which can be subscripted) into the file pointed to by file handle A.
returns number of items written
e.g wcdata(FLOAT_,A,F)
would convert the vector to FLOAT type and write the entire vector F to file.

The vector(s) are converted to datatype ("float","int","char",...) 
before the write occurs.

e.g. wc_data("short",A,V1,V2)  
or
wc_data(SHORT_,A,V1,V2)
   
would convert vectors V1 and V2 to short type before writing to file.

The list of variables can include scalars.
A string constant e.g. w_data(A,"ABCD") is written as a sequence of chars
(see rdata,wdata)

.EF
=============================================================
.BF
wrecord()
.(x
wrecord
.)x 
.FD
w_record(A,Rlen,p1,p2)

writes the parameters p1,p2 into the file pointed to by A.
returns file position in bytes after write
pads the line to Rlen characters then adds newline \n.

.EF
=============================================================
.BF
wc_file()
.(x
wcfile
.)x 
.FD
wc_file(A,C[0],{n})

writes characters to file A (if A is 1 then to stdout ) from char array C.
By default writes till end of line or if n is set then n characters are written.
(see rc_file)


.EF
=============================================================
.BF
w_menu()
.(x
wmenu
.)x 
.FD
w_menu("menu_file",value,item_num)

The function w_menu can be used to change any menu item value.
e.g.
A=w_menu("menu_file",20.0,0)
sets the value for the first menu item of the menu.

.EF
=============================================================
.BF
print()
.(x
print
.)x 
.FD
print ()

 Expansion of variables to an ascii representation of their values will  take place within 
 a double quoted string when the variable name is prefixed with the $ operator.
 The print statements will also allow formating via the C % printf format mechanism.

e.g.
  x= 2.645
<<"$x  %7.2f$x  %4.0f$x %e$x \n"
would give
2.645000     2.64     3 2.645000e+00 

in addition %V will print out the variable name with a space prior to the formatted value of the variable.
For arrays a list format %(n,prerow,arraysep,postrow) specifer allows the vector 
to be printed out in rows of length n.
The number of elements, prerow, arraysep and postrow fields can be strings or variables.
These allow a vector to be printed in formatted rows   

e.g. <<"%(5,\t, ,\n)$Vec "

     0 1 2 3 4
     5 6 7 8 9
     10 11 12 13 14


You can also add a prefix and postfix string to the specifier.
Characters after the number and before the r are printed at the end of each row.
A prefix can be inserted by using a comma

e.g. <<"%(10,-->,/s,<--\n)$V\n"

 -->0 1 2 3 4<--
 -->5 6 7 8 9<--
 -->10 11 12 13 14<--

spaces and tabs can to be specified via \s, \t
<<"%(5\s-->\s,,\s,\s<--\n)$V \n"

 --> 0 1 2 3 4 <--
 --> 5 6 7 8 9 <--
 --> 10 11 12 13 14 <--



.EF
=============================================================
.BF
wprint()
.(x
wprint
.)x 
.FD
w_print(wid,p1,p2,p3)

will print the parameters or text in  window wid.
e.g.
w_print(wid,A," is less than ",B) 
 





.EF
=============================================================
.BF
setwinclip,w_set_clip()
.(x
setwinclip
.)x 
.FD
SetWinClip(wid,x,y,X,Y, {{pix}, {draw_area}})
sets the clipping area of window wid.
By default  the parameters are fractional sizes of the window drawing area,
i.e. not including title area.
If pix is set to one the sizes are in pixels.
If draw_area is set to one ( default zero), then the whole window area is
used. In some applications the user may choose to use the whole window area and
not show the window title region.

e.g.
w_set_clip(wid,0.1,0.1,0.9,0.9)

.EF
=============================================================
.BF
wo_clear_text()
.(x
wocleartext
.)x 
.FD
wo_clear_text(wid,won)
clears the text buffer in window text object won.

.EF
=============================================================
.BF
wo_add_text()
.(x
woaddtext
.)x 
.FD
wo_add_text(wid,won,text)
adds to the text buffer in window text object won.

.EF
=============================================================
.BF
wo_vtile()
.(x
wovtile
.)x 
.FD

wo_vtile(wo_array,x,y,X,Y,[pad])
vertically tiles wo draw areas into window at fractional coordinates, a pad (default 0.01)
can be specified.

.EF
=============================================================
.BF
wo_htile()
.(x
wohtile
.)x 
.FD
wo_htile(wo_array,x,y,X,Y,[pad])
horizontally tiles wo draw areas into window at fractional coordinates, a pad (default 0.01)
can be specified.

.EF
=============================================================
.BF
wo_rctile()
.(x
worctile
.)x 
.FD

wo_rctile(wo_array,x,y,X,Y,rows,cols, [pad])
arranges  wo draw areas into matrix form in a window at fractional coordinates, a pad (default 1% of xrange)
can be specified.

.EF
=============================================================
.BF
wrctile()
.(x
wrctile
.)x 
.FD
wrctile(wo_array,x,y,X,Y,rows,cols,ws, [pad])
arranges  windows into matrix form in a screen (ws, 0-15) at fractional coordinates, a pad 
(default 1% of xrange - can be zero no separation between windows) can be specified.

.EF
=============================================================
.BF
creategwob,createwo,cWo()
.(x
cWo, create window object
.)x 
.FD
cWo(wid,"type",@resize,x,y,X,Y,[rel])
returns window object number.

The type field specifies the function served by the window object.
The xy cordinates of box can be specified 
as relative fraction of the window
or as real coordinates
corresponding to XY scales of window 
of window  when rel parameter is set to 0 default or 1 respectively.
The value field can be used to specify the symbol shown.
The rel parameter should be set to 2 for a TITLE_BUTTON
.nf
type	name	function
TITLE_BUT,TB shown as a box with a symbol in title region
        returns name when activated	
TEXT shows text in box 
        allows text to be input when activated	
SYMBOL shows symbol in box which can be placed any where
	in the window. Returns name when activated.
BUTTON shows name in box which can be placed any where
	in the window. Returns name when activated.
BUTTON_VALUE,BV shows name in box plus current value 
	which can be placed any where
	in the window. The current value can be changed when
	activated via mouse click.
	This value can be obtained via get_wo_value call.

wo_id = createGwob(wid,@bv,@name,"FRQ",@value,100,@style,"SVB",@resize,x,y,X,Y,[rel])
 creates a button with name FRQ and a shown value of 100

The value for a 'button' can be shown alongside,below, above the name of that button
using the @style tag-value e.g.
 @style,"SVB"     below
 @style,"SVR"     right
 @style,"SVL"     left
 @style,"SVT"     top
 @style,"SVO"     only the value is shown 


.EF
=============================================================
.BF
Set_wo()
.(x
Setwo
.)x 
.FD
set_wo(woid,"value",value)
returns window object number.



.EF
=============================================================
.BF
w_set_wo_value()
.(x
wsetwovalue
.)x 
.FD
w_set_wo_value(wid,wo_num, value )
set value of window object number to value

.EF
=============================================================
.BF
w_set_wo_help()
.(x
wsetwohelp
.)x 
.FD
w_set_wo_help(wid,wo_num, help)
sets help line  of window object number to help string
(see get_wo_help,get_wo_text)

.EF
=============================================================
.BF
set_wo_text()
.(x
setwotext
.)x 
.FD
set_wo_text(wid,wo_num, &C[0] )
updates window object text with text from
char array

.EF
=============================================================
.BF
get_wo_text()
.(x
getWotext
.)x 
.FD
get_wo_text(woid, &C[0], {max_char} )
gets text from window object into char array.

.EF
=============================================================
.BF
SpawnGWM()
.(x
SpawnGWM()
.)x 
.FD
SpawnGWM()
 launches a graphic window manager --- now all graphic commands are sent via pipes and/or shared memory
 to that graphic screen



.EF
=============================================================
.BF
SpawnAsl()
.(x
SpawnAsl
.)x 
.FD
id =  SpawnAsl(script, arg1, arg2, ...)

Spawns off a asl process which runs named script.
The handle id  is used in routines that write to and from mother and child processes.

see :-

nwr=WriteChild(id,Vec,nb)
nwr=WriteMother(Vec,nb)

Vec=ReadChild(id,nwr)
Vec=ReadMother(nwr)

nwr=WriteMotherMsg(Vec,nb)
nwr=WriteChildMsg(id,Vec,nb)


sz=ReadChildMsg(id,Vec)
sz=ReadMotherMsg(Vec)


.EF
=============================================================
.BF
ReadChild()
.(x
ReadChild
.)x 
.FD
Vec =  ReadChild(id, [nbr])

reads from a spawned script process - Vec is a dynamically created char array 
The function attempts to read  nbr bytes- The size of Vec  ( use Caz(Vec))
is the number of bytes read. If nbr is not specified the function reads what is in the pipe
and returns. The other process on the writing side  uses WriteMother(Vec)

.EF
=============================================================
.BF
ReadMother()
.(x
ReadMother
.)x 
.FD
Vec =  ReadMother([nbr])

A spawned process reads from the mother process - Vec is a dynamically created char array 
The function attempts to read  nbr bytes- The size of Vec  ( use Caz(Vec))
is the number of bytes read. If nbr is not specified the function read what is the pipe
and returns. The other process on the writing side  uses WriteChild(id,Vec)

.EF
=============================================================
.BF
ReadChildMsg()
.(x
ReadChildMsg
.)x 
.FD
sz =  ReadChildMsg(id, Vec, [maxreads])

reads from a spawned script process - Vec is a char array  (dynamically expanded)
The function  first reads  a header which indicates the size of following message-
which is then read into the array. The number of message bytes read is returned.
A zero return means no message was ready to be read - functions returns immediately.
If the message read fails - a negative number is returned 
indicating the number of bytes still to read. 
The other process must use  - WriteMotherMsg(Vec)
If maxreads is set to zero - the function blocks (reads-sleeps-reads) until the message is read.
The default is set to try a hundred reads (sleep interval 0.05 secs) and then return.
 An incomplete message read means sender and receiver have to resychronize.

.EF
=============================================================
.BF
ReadMotherMsg()
.(x
ReadMotherMsg
.)x 
.FD
sz =  ReadMotherMsg( Vec, [maxreads])

reads from a spawned script process - Vec is a char array  (dynamically expanded)
The function  first reads  a header which indicates the size of following message-
which is then read into the array. The number of bytes read is returned.
If the read fails - a negative number is returned indicating the number of bytes still
to read. The other process must use  - WriteChildMsg(id,Vec)






.EF
=============================================================
.BF
writeSignal()
.(x
writeSignal
.)x 
.FD
writeSignal(sbn,file_name,{start},{stop},{keep_times}{swabit})

writes the  signal from the buffer  sbn ( obtained previously  createSignalBuffer(),
and where the signal was recorded or read).
The samples are selected via start sample number to stop sample number
and written to a named file.

Returns number of samples written. 
By default a header will be written at start of file,
use write_buffer for no header version.
e.g
write_signal(wid,file_name,s1,s2) will write the signal 
inclusive between sample s1 and sample s2.
and
write_signal(wid,file_name) will write the signal 
using the CURRENT window coordinates.
Setting s1 to [0,1,or 2] and leaving s2 unset or set to -1
will have the following effects
write_signal(wid,file_name,-1) : will write the signal using current window times.
write_signal(wid,file_name,0) : will write the entire buffer.
write_signal(wid,file_name,1) : will write the select region.
write_signal(wid,file_name,2) : will write the signal using the PREVIOUS window coordinates.
write_signal(wid,file_name,1,-1,1) : will write select_region 
and write times of region in the header.
The default is to use zero and the duration as start and stop times.


(see write_buffer)

.EF
=============================================================
.BF
write_buffer()
.(x
writebuffer
.)x 
.FD
write_buffer(wid,file_name,{start},{stop},{swab})
writes the buffer associated with wid 
from start sample to stop sample to a file called file_name.
write_buffer(wid,file_name) will write the buffer
using the CURRENT window coordinates.
If swab is set to 1 then the byte order is swopped
Setting s1 to [0,1,or 2] and leaving s2 unset or set to -1
will have the following effects
write_buffer(wid,file_name,0) : will write the entire buffer.
write_buffer(wid,file_name,1) : will write the select region.
write_buffer(wid,file_name,2) : will write the buffer using the previous window coordinates.
(see write_signal)



.EF
=============================================================
.BF
wrt_chan_head()
.(x
wrtchanhead
.)x 
.FD
wrt_chan_head(FN,start,stop,noc,type,sf,fs,fl,nic,sod,[name,ll,ul],...)
FN is file number.
start and stop time
noc number of channels
type "float", "int" ,"short"
sf   original sampling frequency
fs   measurement time interval - shift
fl   analysis window time
nic  number of measurements
sod  data offset in bytes
for each channel (parameter)
name
ll minimum value
ul maximum value ( for subsequent plot purposes)

.EF
=============================================================
.BF
wrt_frame_head()
.(x
wrtframehead
.)x 
.FD
wrt_frame_head(FN,start,stop,name,type,sf,fs,fl,ll,ul,vl,np,nof,sod)
FN is file number.
start and stop time
name  title
type "float", "int" ,"short"
sf   original sampling frequency
fs   measurement time interval - shift
fl   analysis window time
ll minimum value
ul maximum value ( for subsequent plot purposes)
vl vector length
np additional parameters (default 0)
nof  number of measurements
sod  data offset in bytes
for each channel (parameter)



.EF
=============================================================
.BF
w_clear()
.(x
wclear
.)x 
.FD
w_clear(wid)

clears window to window background color.

.EF
=============================================================
.BF
w_clip_clear()
.(x
wclipclear
.)x 
.FD
w_clip_clear(wid,{color})
by default
clears clip region of window to window background color.
otherwise to the specified color( name or number).
.EF
=============================================================
.BF
w_erase()
.(x
werase
.)x 
.FD
w_erase(wid,n)

if n is set to zero 
clears window from current pen position to window background color.
if n is set to one
clears window to current pen position to window background color.
if n is set to two
clears window to current pen position to window background color.
and resets pen position to home (i.e. 0,0)



.EF
=============================================================
.BF
w_line_erase()
.(x
wlineerase
.)x 
.FD
w_line_erase(wid,n)

if n is set to zero 
clears line from current pen position to window background color.
if n is set to one
clears line to current pen position to window backround color.
if n is set to two
clears line to current pen position to window background color.
and resets pen position to line beginning.


.EF
=============================================================
.BF
w_title()
.(x
wtitle
.)x 
.FD
w_title(wid,"NAME", {show_title}, {center})
gives (changes) window title.
show_title should be set to 1 (default 0) to activate title region,
otherwise the whole window area is used for drawing.
The default is to center the title, set center to zero to position title at
far left of title area.

.EF
=============================================================
.BF
CreateGwindow()
.(x
cWi
.)x 
.FD
wid=cWi("title")


 returns an id (handle) to the window

other aspects of the window can be subsequently altered by calls
to sWi e.g.
sWi(_WOID,wid,_WHUE,RED_)  ---- change foreground color

.EF
=============================================================
.BF
sWi()
.(x
sWi
.)x 
.FD
the arguments to sWi are of the form tag, value

sWi(_WOID,wid,_WCLEARPIXMAP,ON_,_WPENHUE,RED)

the value is typical an int or a known constant e.g. ON_,RED_,BLACK_, OFF_
or a function returning a float pointer
e.g.  wbox(0,0,10.5,20.5)
so to set scales of a window
sWi(_WOID,wid,_WSCALES,wbox(0,0,1,2))

action,ON_    would perform the option
action,OFF_   would either not perform the action or would switch the attribute off.



the list of tag,values and actions is given below

tag                 value(s)                action
_WCLEAR,ON_    				: clears entire area of window      
_WCLEARCLIP,ON_                               : clears  the main drawing area of window      
clearpixmap                             : clears the pixmap
move              x,y                   : sets  lower left of window position - to x,y screen pixel postion
_WPIXMAP,ON_                                : drawing operations to  the current pixmap
_WPIXMAP,OFF_                               : drawing operations to  the current pixmap


resize           x,y,X,Y,ws             : sets size of window to x,y,X,Y  as fraction of screen (0 to 1.0) 
                                             which screen ws (0 to 15)
rmove              x,y                  : adds x,y to lower left of window position - relative move of window
screendrawon                            : drawing operations to  the current screen - independent of draw operations to pixmap
screendrawoff                           : no draw operations to  the current screen - 
showpixmap                              : shows the current pixmap
savepixmap                              : saves the current pixmap
save,store				: the window area bitmap is saved           
scroll            x,y                   : the window are bitmap is scrolled by x,y pixels + scroll to left  

tmsg, string                     :prints  a text message in title area of window


if the user has enabled draw operations results of graphics are drawn to 
screen immediately and optionally also drawn to a pixmap.
if user has set draw operations to 0, but has enabled
draw operations to pixmap 
then showpixmap will display the current pixmap.
Showing the pixmap after graphics have completed allows for
animation effects.


.EF
=============================================================
.BF
sWo()
.(x 
sWo(_WOID,wo_id) --- set a window object's attributes
.)x 
.FD
sWo (_WOID, wo_id, [action, value,...])

the arguments to sWi are of the form tag,value 
where the tag is the action, which is followed by an optional list of values

tag,{value,...}
Actions will require values or parameters. 

constants or variables.
actions are basically the name of function call 
with a list following args 

e.g.
sWo(_WOID,wo_id,_WDRAW,ON_,_WPIXMAP,ON_,_WHUE,BLACK_,_WFUNC,"ip_wo_value",_WREDRAW,ON_);
sWo(_WOID,wo_id,_WSCALES,wbox(0.0,0.0,1.0,1.0));


the window object referred to by wo_id has the attribute of @drawon
@func is set to ip_wo_value -- so that a click in the window object 
then allows user to update its text value via keyboard
redraw - the window object is redrawn after this setgwob call

Text and graphics are drawn by default immediately to screen, 
but they can be directed instead to a pixmap
which can then later be displayed.
pixmapoff   : pixmap drawing is disabled
pixmapon    : pixmap drawing is enabled
clearpixmap : clears the current pixmap
showpixmap  : shows the current pixmap
savepixmap  : saves the current pixmap
drawon      : turns on drawing to screen (not into the pixmap)
drawoff     : turns off drawing to screen 


a list of action, values follows -- if an action requires a value(s) - the values must be supplied

"value" string or number
"type"  string {"BV","SYMBOL","MENU","GRAPH"}

A window object can be resized to a window using the following
sWo(wo_id,_WRESIZE, wbox(0.5,0.2,0.7,0.9,[0,1,2,3]))
the tag _WRESIZE is followed by its args -- with resize an optional 5th argument that allows
the resize to be done as fractional size (0), 
or pixel offset (1) of the parent window
or relative to real scales (2) of the parent window
or as grid position (3) of the parent window - default grid is 10x10

TBD  === update this discussion for new form of sWo

_WREDRAW,ON_ will redraw the entire object while update just refreshes the area showing its value.

Tag Value(s) sets


_WCOLOR, hue

---- hue can be a index to color map or a defined color e.g. RED_,YELLOW_, GREEN_
or

??---- a name e.g. html color name like lilac - sinfo htmlcolors gives curren table


@textr, string,x,y, position, rotation, hue

@textf, string,x,y, position, rotation, hue



@func, string {inputValue,wo_menu, ...)
e.g.

sWo(won,@value,"3",@func,"inputValue")
 would allow user when cliking on the Wo to enter a new value via the grapic interface.
 an option of wo_menu - would pop up a menu (menu items - can be set via a comma delimited list)
 allowing user to set value via menu selection.
  e.g.
sWo(won,@value,"Veg",@func,"wo_menu",@menu,"Meat,Fish,Veg,Fruit")
  


There are a number of window object attributes that can be set
e.g.
 sWo(frq1wo,@highlight,1,@update)
 would set highlight on for frq1wo  object.

Plot operations using Swo :
 these are of the pattern of a tag indicated the oblect to be plotted
followed by a number of parameters controlled the plot operation.
e.g. 

sWo(grwo,@line,x,y,X,Y)
most are the same as described via the plot function
e.g.
plot(grwo,@line,x,y,X,Y);

won=cWo(cp,@BS, ...);
sWo(won,@CSV,"a,b,c,4,5", [2]);

sets the value fields on an wo button state object so that on subsequent clicks the value
returned cycles through the list.
By default it will start at beginning, but the initial field can be set by optional argument.
In the example above the value "c" would be the value obtained on the flrst click.


.EF
=============================================================


.BF
sWo()
.(x 
sWo(_WOID,wo_id,_WCLEAR,ON_) --- clears draw area of window object
.)x 
.FD
clears draw area of window object wo_id

.EF
=============================================================

.BF.BF
sWo()
.(x 
sWo(woid,@clipsize,[0.1,0.1,0.9,0.9]) --- sets the draw area of window object
.)x 
.FD
sets the draw area of window object  as fractional  size of whole wobj area.
(default - 0.1,0.1,0.9,0.9)

.EF
=============================================================

htmlcolors()
.(x 
htmlcolors
.)x 
.FD
htmlcolors()
returns array of html colors
( "AliceBlue",		240,	248,	255,	0xf0f8ff );
( "AntiqueWhite",		250,	235,	215,	0xfaebd7 );
( "Aqua",		0,	255,	255,	0x00ffff );
( "Aquamarine",		127,	255,	212,	0x7fffd4 );
( "Azure",		240,	255,	255,	0xf0ffff );
( "Beige",		245,	245,	220,	0xf5f5dc );
( "Bisque",		255,	228,	196,	0xffe4c4 );
( "Black",		0,	0,	0,	0x000000 );
( "BlanchedAlmond",		255,	235,	205,	0xffebcd );
( "Blue",		0,	0,	255,	0x0000ff );
( "BlueViolet",		138,	43,	226,	0x8a2be2 );
( "Brown",		165,	42,	42,	0xa52a2a );
( "Burlywood",		222,	184,	135,	0xdeb887 );
( "CadetBlue",		95,	158,	160,	0x5f9ea0 );
( "Chartreuse",		127,	255,	0,	0x7fff00 );
( "Chocolate",		210,	105,	30,	0xd2691e );
( "Coral",		255,	127,	80,	0xff7f50 );
( "CornflowerBlue",		100,	149,	237,	0x6495ed );
( "Cornsilk",		255,	248,	220,	0xfff8dc );
( "Cyan",	        	0,	255,	255,	0x00ffff );
( "DarkBlue",		0,	0,	139,	0x00008b );
( "DarkCyan",		0,	139,	139,	0x008b8b );
( "DarkGoldenrod",		184,	134,	11,	0xb8860b );
( "DarkGray",		169,	169,	169,	0xa9a9a9 );
( "DarkGreen",		0,	100,	0,	0x006400 );
( "DarkKhaki",		189,	183,	107,	0xbdb76b );
( "DarkMagenta",		139,	0,	139,	0x8b008b );
( "DarkOliveGreen",		85,	107,	47,	0x556b2f );
( "DarkOrange",		255,	140,	0,	0xff8c00 );
( "DarkOrchid",		153,	50,	204,	0x9932cc );
( "DarkRed",		139,	0,	0,	0x8b0000 );
( "DarkSalmon",		233,	150,	122,	0xe9967a );
( "DarkSeaGreen",		143,	188,	143,	0x8fbc8f );
( "DarkSlateBlue",		72,	61,	139,	0x483d8b );
( "DarkSlateGray",		47,	79,	79,	0x2f4f4f );
( "DarkTurquoise",		0,	206,	209,	0x00ced1 );
( "DarkViolet",		148,	0,	211,	0x9400d3 );
( "DeepPink",		255,	20,	147,	0xff1493 );
( "DeepSkyBlue",		0,	191,	255,	0x00bfff );
( "DimGray",		105,	105,	105,	0x696969 );
( "DodgerBlue",		30,	144,	255,	0x1e90ff );
( "Firebrick",		178,	34,	34,	0xb22222 );
( "FloralWhite",		255,	250,	240,	0xfffaf0 );
( "ForestGreen",		34,	139,	34,	0x228b22 );
( "Fuschia",		255,	0,	255,	0xff00ff );
( "Gainsboro",		220,	220,	220,	0xdcdcdc );
( "GhostWhite",		255,	250,	250,	0xf8f8ff );
( "Gold",		255,	215,	0,	0xffd700 );
( "Goldenrod",		218,	165,	32,	0xdaa520 );
( "GoldenrodYellow",	250,	250,	210,	0xfafad2 );
( "Gray",           	128,	128,	128,	0x808080 );
( "Green",		        0,	128,	0,	0x008000 );
( "GreenYellow",		173,	255,	47,	0xadff2f );
( "Honeydew",		240,	255,	240,	0xf0fff0 );
( "HotPink",		255,	105,	180,	0xff69b4 );
( "Indigo",		        75,	0,	130,	0x4b0082 );
( "IndianRed",		205,	92,	92,	0xcd5c5c );
( "Ivory",		        255,	255,	240,	0xfffff0 );
( "Khaki",		        240,	230,	140,	0xf0e68c );
( "Lavender",		230,	230,	250,	0xe6e6fa );
( "LavenderBlush",		255,	240,	245,	0xfff0f5 );
( "LawnGreen",		124,	252,	0,	0x7cfc00 );
( "LemonChiffon",		255,	250,	205,	0xfffacd );
( "LightBlue",		173,	216,	230,	0xadd8e6 );
( "LightCoral",		240,	128,	128,	0xf08080 );
( "LightCyan",		224,	255,	255,	0xe0ffff );
( "LightGoldenrod",		238,	221,	130,	0xeedd82 );
( "Lilac",		        200,	162,	200,	0xc8a2c8 );
( "LightGray",		211,	211,	211,	0xd3d3d3 );
( "LightGreen",		144,	238,	144,	0x90ee90 );
( "LightPink",		255,	182,	193,	0xffb6c1 );
( "LightSalmon",		255,	160,	122,	0xffa07a );
( "LightSeaGreen",		32,	178,	170,	0x20b2aa );
( "LightSkyBlue",		135,	206,	250,	0x87cefa );
( "LightSlateBlue",		132,	112,	255,	0x8470ff );
( "LightSlateGray",		119,	136,	153,	0x778899 );
( "LightSteelBlue",		176,	196,	222,	0xb0c4de );
( "LightYellow",		255,	255,	224,	0xffffe0 );
( "Lime",		        0,	255,	0,	0x00ff00 );
( "LimeGreen",		50,	205,	50,	0x32cd32 );
( "Linen",		        250,	240,	230,	0xfaf0e6 );
( "Magenta",		255,	0,	255,	0xff00ff );
( "Maroon",		        128,	0,	0,	0x800000 );
( "MedAquamarine",		102,	205,	170,	0x66cdaa );
( "MediumBlue",		0,	0,	205,	0x0000cd );
( "MediumOrchid",		186,	85,	211,	0xba55d3 );
( "MediumPurple",		147,	112,	219,	0x9370db );
( "MediumSeaGreen",		60,	179,	113,	0x3cb371 );
( "MedSlateBlue",		123,	104,	238,	0x7b68ee );
( "MedSpringGreen",		0,	250,	154,	0x00fa9a );
( "MedTurquoise",		72,	209,	204,	0x48d1cc );
( "MedViolet-Red",		199,	21,	133,	0xc71585 );
( "MidnightBlue",		25,	25,	112,	0x191970 );
( "MintCream",		245,	255,	250,	0xf5fffa );
( "MistyRose",		255,	228,	225,	0xe1e4e1 );
( "Moccasin",		255,	228,	181,	0xffe4b5 );
( "NavajoWhite",		255,	222,	173,	0xffdead );
( "Navy",		0,	0,	128,	0x000080 );
( "OldLace",		253,	245,	230,	0xfdf5e6 );
( "Olive",		128,	128,	0,	0x808000 );
( "OliveDrab",		107,	142,	35,	0x6b8e23 );
( "Orange",		255,	165,	0,	0xffa500 );
( "OrangeRed",		255,	69,	0,	0xff4500 );
( "Orchid",		218,	112,	214,	0xda70d6 );
( "PaleGoldenrod",		238,	232,	170,	0xeee8aa );
( "PaleGreen",		152,	251,	152,	0x98fb98 );
( "PaleTurquoise",		175,	238,	238,	0xafeeee );
( "PaleVioletRed",		219,	112,	147,	0xdb7093 );
( "PapayaWhip",		255,	239,	213,	0xffefd5 );
( "PeachPuff",		255,	218,	185,	0xffdab9 );
( "Peru",		205,	133,	63,	0xcd853f );
( "Pink",		255,	192,	203,	0xffc0cb );
( "Plum",		221,	160,	221,	0xdda0dd );
( "PowderBlue",		176,	224,	230,	0xb0e0e6 );
( "Purple",		128,	0,	128,	0x800080 );
( "Red",		255,	0,	0,	0xff0000 );
( "RosyBrown",		188,	143,	143,	0xbc8f8f );
( "RoyalBlue",		65,	105,	225,	0x4169e1 );
( "SaddleBrown",		139,	69,	19,	0x8b4513 );
( "Salmon",		250,	128,	114,	0xfa8072 );
( "SandyBrown",		244,	164,	96,	0xf4a460 );
( "SeaGreen",		46,	139,	87,	0x2e8b57 );
( "Seashell",		255,	245,	238,	0xfff5ee );
( "Sienna",		160,	82,	45,	0xa0522d );
( "Silver",		192,	192,	192,	0xc0c0c0 );
( "SkyBlue",		135,	206,	235,	0x87ceeb );
( "SlateBlue",		106,	90,	205,	0x6a5acd );
( "SlateGray",		112,	128,	144,	0x708090 );
( "Snow",		255,	250,	250,	0xfffafa );
( "SpringGreen",		0,	255,	127,	0x00ff7f );
( "SteelBlue",		70,	130,	180,	0x4682b4 );
( "Tan",		210,	180,	140,	0xd2b48c );
( "Teal",		0,	128,	128,	0x008080 );
( "Thistle",		216,	191,	216,	0xd8bfd8 );
( "Tomato",		255,	99,	71,	0xff6347 );
( "Turquoise",		64,	224,	208,	0x40e0d0 );
( "Violet",	        	238,	130,	238,	0xee82ee );
( "VioletRed",		208,	32,	144,	0xd02090 );
( "Wheat",		        245,	222,	179,	0xf5deb3 );
( "White",	        	255,	255,	255,	0xffffff );
( "WhiteSmoke",		245,	245,	245,	0xf5f5f5 );
( "Yellow",		255,	255,	0,	0xffff00 );
( "Grey",		128,	128,	128,	0x808080 );
( "YellowGreen",	154,	205,	50,	0x9acd32 );

.EF
=============================================================
.BF
savepixmap()
.(x 
sWo (woid,@savepixmap)
.)x 
.FD
sWo (woid, @savepixmap)
see sWo.

.EF
=============================================================
.BF
clearpixmap()
.(x 
sWo (woid)
.)x 
.FD
sWo (woid, @clearpixmap)
see sWo.

.EF
=============================================================
.BF
textr()
.(x 
sWo (woid)
.)x 
.FD
sWo (woid, @textr, "string", x,y, str_posn, rotate, hue)
prints text at x,y position using window object scales, 
the string will start, center, or end at
the x,y, position if str_posn at 0,1,2 respectively. The string can be rotated.
Hue sets the string color.

.EF
=============================================================
.BF
textf()
.(x 
sWo (woid)
.)x 
.FD
sWo (woid, @textf, "string", x,y, str_posn, rotate, hue)
prints text at x,y fractional position of clip window, 
the string will start, center, or end at
the x,y, position if value of str_posn is 0,1,2 respectively. 
The string can be rotated (0,90,-90) 
Hue sets the string color.

.EF
=============================================================
.BF
vpc()
.(x
vpc
.)x 
.FD
vpc - (woid, array,  cmapi, x, y, direction)
 plot a pixelstrip of points  where each color is the element value. Parameter cmapi is index into the 
 color map  -- array is type CHAR so each pixel is a color referenced by cmapi plus array value (256 colors) 
 The start pixel is at an initial coordinate x,y in clip window ( 0,0 is upper left hand corner of drawing area)
 The parameter direction determines whether vector is plotted up (1) ,down (-1),left->right (0) , right->left (2)
 from initial x,y location.



.EF
=============================================================
.BF
w_delete()
.(x
wdelete
.)x 
.FD
w_delete(wid)
deletes window


.EF
=============================================================
.BF
w_map()
.(x
wmap
.)x 
.FD
w_map(wid)

maps the window - graphic operations now occur.


.EF
=============================================================
.BF
w_move()
.(x
wmove
.)x 
.FD
w_move(wid,x,y,{r})

moves window to new x,y position
if r parameter set to 1 then then move is relative to the current 
position

.EF
=============================================================
.BF
w_query()
.(x
wquery
.)x 
.FD
w_query(wid,default_answer,"text",{p1,p2,...})

prints prompt string in window - user can type string or hit return.
Carriage return only returns the default answer.
e.g.
f_name=w_query(wid,f_name,"file name ?<",f_name,">")

.EF
=============================================================
.BF
w_resize()
.(x
wresize
.)x 
.FD
w_resize(wid,x,y,X,Y,ws,{pix})

resizes window to new x,y X,Y coordinates where x,y are fractional sizes of screen
the window can be assigned to different screens - default 0
if pix is set to one then xy coordinates are pixel coordinates of current screen.
(default zero - to use fractional sizes)

.EF
=============================================================
.BF
w_pop()
.(x
wpop
.)x 
.FD
w_pop(wid)

pops window to front.


.EF
=============================================================
.BF
w_push()
.(x
wpush
.)x 
.FD
w_push(wid)

pushes window to back.


.EF
=============================================================
.BF
w_real_xor()
.(x
wrealxor
.)x 
.FD
w_real_xor(wid,rx,ry,rX,rY)
exculsive or of part window image specified as real coors (e.g. white-black , black-white).

.EF
=============================================================
.BF
mouseCursor()
.(x
mouseCursor()
.)x 
.FD
mouseCursor(woid,["cursor_name", curs_id],{px,py})

shows cursor image in  window or windowobject. 
Cursor images reside in the FONTS directory.
(or in X window version are those supplied)
If px and py are set as proportional to window area then
mouse pointer is moved to new location within window.
name = "hand"
name = "cross"

or can use cursor_id ,  CROSS_, HAND_, ...

.EF
=============================================================
.BF
w_time_curs()
.(x
wtimecurs
.)x 
.FD
w_time_curs({wid})
shows the time cursors (start,finish) for window. 
(default) show then in all time windows.


.EF
=============================================================
.BF
w_store()
.(x
wstore
.)x 
.FD
w_store(wid)
stores window image

.EF
=============================================================
.BF
w_refresh()
.(x
wrefresh
.)x 
.FD
w_refresh(wid,{area})
refreshes previously stored window image (using wstore)
if area = 1 then only the clip area
area = 2 use optional stored image via wstoreb
area = 3 clip area use optional stored image via wstoreb

.EF
=============================================================
.BF
w_xor()
.(x
wxor
.)x 
.FD
w_xor(wid)
exculsive or of window image (e.g. white-black , black-white)

# Glines

.EF
=============================================================
.BF
creategline()
.(x
creategline,cGl
.)x 
.FD

cGl(wid,@TY,YV)
cGl(wid,@TXY,XV,YV)
cGl(wid,@TXYP,XYV)
Y vector of y values
XV,YV  vecotrs of X and Y values
XYV vector of XYpairs

first parameter is the id of the window area and then follows a tage fpr the type of line
and the array of values to specify the xy positions.
where the tag can be TY,TXY,TXZ,TXYP,THIST, TCURSOR and the following parameters are the vectors




cGl
returns handle for gline that can then be drawn.

Attributes of the gline are set via tag,value pairs
e.g. "X",x , "type", "XY"
where the tag is a string naming the attribute or property  (written as @tag, to distinguish
from the following value arguments)
and the value is
a constant or variable (scalar or vector) containing the value.
The types of lines that can be drawn are :-
"Y" for a vector of values drawn linearly along a xaxis,
"XY"  where the yvec values are plotted against the xvec values.
"HIST" where the values are shown as filled rectangles with base width
set by "X",x 
e.g.
refgl=CreateGline(wid,@THIST,H,binwidth,@color,RED_,@name,"rainfall")

xygl=CreateGline(wid,@TXY,XV,YV,@color,BLUE_)
where XV and YV are vectors of values for xy positions.

the line can then be drawn by calling DrawGline
  DrawGline(refgl)

A gline can be deleted by calling deletegline(handle)
Current values can be changed by calling
setgline(handle, [tag,value, ...]
and then redrawn

xygl=cGl(wid,@TXY,xvec,yvec,@color,RED_,@name,"XYPLOT")
xypgl=CreateGline(wid,@TXYP,xyvec,@color,RED_,@name,"XYPLOT")

the tag TXY is used for XY plots -- @TXY is followed by two args which are the x vector and y vector to be plotted.
the tag TY is used for Y plots -- @TY is followed by one arg which is y vector to be plotted 
 (against an implied linear x vector with unit increments) 

(see setgline)

.EF
=============================================================
.BF
setgline()
.(x
setgline,sGl
.)x 
.FD
SetGline(_GLID,gl_id, _TAG, [VALUE,VECTOR,STRUCT], _TAG2,[VALUE,VECTOR,STRUCT]....);
parameters are sets of tag,value pairs. The value can number, variable or vector, or struct,

e.g. prior to drawing a gline the line parameters can be set
the first two parameters set the ID for the line  _GLID, id
the following pairs can used to set the vectors for x,y values
line color, line symbols etc.

the foloowing would set line color to red , the x vector and the y vector for the x,y values
for each point and have a triangle symbol plotted at each point.
  sGl(_GLID,wt_gl, _GLHUE, RED_, _GLXVEC, DVEC, _GLYVEC, WTVEC,_GLSYMLINE, TRI_);


tag ,  value 






# Script read/list functions
.EF
=============================================================
.BF
Slist()
.(x
Slist
.)x 
.FD
Slist([start],[end])
list the current lines of script

# Script functions

# NEURAL-NET library
//  ANN ---

.EF
=============================================================
.BF
get_net()
.(x
getnet()
.)x 
.FD
getnet()
obtains handle for a net

.EF
=============================================================
.BF
getnetarch()
.(x
getnetarch()
.)x 
.FD
get_net_arch(N,&Iarch[0])
obtains architecture for net
      Iarch[0] = number of layers in net
      Iarch[1] = number of nodes in net
      Iarch[2] = number of connections in net
      Iarch[3] = number of input nodes in net
      Iarch[4] = number of output nodes in net
      Iarch[5] = number of  nodes in first hidden layer net
      Iarch[6] = number of  nodes in second hidden layer net


.EF
=============================================================
.BF
setnetarch()
.(x
setnetarch()
.)x 
.FD
set_net_arch(N,layers,nin,nout,n_first_hid,n_second_hid)
sets up net architecture for multi-layer perceptron for net N.
number of layers, in_nodes, out_nodes, number of nodes in
first hidden layer, second layer.
The number of hidden layers is arbitary but there is little justification
for than two normally (nonlinear, disjoint sets). More than two might be
used when hierarchically combining smaller nets.
The architecture can also be set via
set_net_arch(N,&Iarch[0]) 
where Iarch array is setup via get_net_arch()

.EF
=============================================================
.BF
setnetlearn()
.(x
setnetlearn()
.)x 
.FD
set_net_learn(N,eta,alpha,theta)
sets learn parameters for net N.


.EF
=============================================================
.BF
setneteta()
.(x
setneteta()
.)x 
.FD
set_net_eta(N,eta)
sets learning rate  parameter for net N.

.EF
=============================================================
.BF
set_net_type()
.(x
setnettype()
.)x 
.FD
set_net_eta(N,type)
sets net type,
current types are
sff - strictly feed-forward
dca - sff plus all input nodes are directly connected to output nodes
ntn - nodes can be wired to other nodes in lower layer via wire_nodes routine

.EF
=============================================================
.BF
set_net_conn()
.(x
setnetconn()
.)x 
.FD
set_net_conn(N)
initialises the connections for a net, if type is 'sff'
all nodes in upper layer are wired to all nodes in lower
'dca' - like 'sff' plus all input nodes are directly connected to output nodes
'ntn' -  the connections are unset - to be specifically wired via wire-nodes command.

.EF
=============================================================
.BF
wirenodes()
.(x
wirenodes()
.)x 
.FD
wire_nodes(N,upper_l,lower_l,fnodes,tnodes)
Wire nodes from upper layer to lower layer.
The input layer is layer 0.
The nodes can be selected with following expression
-1, all nodes in the layer
d-d inclusive range
d:d:d individual nodes
the expression can include repeated selections
e.g. 4-7:9-11:14:15

nodes are indexed 0,...,n-1 where there are n nodes in that
layer.

.EF
=============================================================
.BF
clampconn()
.(x
clampconn()
.)x 
.FD
clampConn(N,from_node,to_node)
clamps the conection (no change during subsequent training) from node to node.
nodes indexed from 0 to number of nodes in net.

.EF
=============================================================
.BF
turnoff_conn()
.(x
turnoffConn(),pruneConn()
.)x 
.FD
pruneConn(N,from_node,to_node)
prunes (turns off) the conection (no change during subsequent training) from node to node.
nodes indexed from 0 to number of nodes in net.
(turnon_conn, clamp_conn, set_conn)

.EF
=============================================================
.BF
set_conn()
.(x
setconn()
.)x 
.FD
setConn(N,from_node,to_node,[state,[wt_value]])
sets the connection (no change during subsequent training) from node to node.
nodes indexed from 0 to number of nodes in net.
state 0 off, 1 On, 2 clamp. default turn On.
Additionally if set wt_value  adjust the wt to specified value. 

.EF
=============================================================
.BF
rand_net_wts()
.(x
randnetwts()
.)x 
.FD
rand_net_wts (N,adjust,seed,sz)
randomize weights for the net N.
if adjust =1 , add the random weight to the current.
seed use for seeding random number.
sz if the range of random weight (default 2.0 - (2.0 <-> -2.0)


.EF
=============================================================
.BF
train_net_pat()
.(x
trainnetpat()
.)x 
.FD
train_net_pat(N,pat_number,&Input[0],&Target[0],[print])
using net N, pattern n (from a set of patterns) train the net
on the pattern, optionally print out net state

.EF
=============================================================
.BF
print_net_pat()
.(x
printnetpat()
.)x 
.FD
print_net_pat(N,pat_number,&Input[0],&Target[0],[train])
using net N, pattern n (from a set of patterns) 
print out net state for using the pattern to activate net, optionally
train (adjust wts for this this net activation)


.EF
=============================================================
.BF
trainNet()
.(x
trainnet()
.)x 
.FD
nc=trainNet(N, Input, Target, nsweeps,[Output],[Opc])
using net N, and input and target arrays
train the net for n sweeps of the all the patterns
return number correct
set up of Input and Target and architecture of the net
Optionally supply a Output vector(float) whihc will contain
the actual output of the net for each training pattern,
and an Opc vector(int) that contains whether each pattern
was judged correct.


.BF
testNet()
.(x
testnet()
.)x 
.FD
nc=testNet(N, Input, Target, nsweeps,[Output],[Opc])
using net N, and input and target arrays
test the net for n sweeps of the all the patterns
return number correct. (see trainNet)


///////////////////////////////// STRING OPS ///////////////////////////////////////////////

.EF
=============================================================
.BF
pickc()
.(x
pickc
.)x 
.FD
pickc(string,index)
used to pick a character out of a  string variable
index in string (0...length-1)
if index is set  negative (-1 being the last character of the string,-2 the penultimate, ...) 
then characters from the end of the string can be selected.

.EF
=============================================================
.BF
rover()
.(x
rover
.)x 
.FD
w3=rover(w1,w2,index)
replace a characters of w1 at index position with string w2.
The replacement will extend the string if needed, as long as index is within the first string.
If index is negative the replacement is offset to the end of the string
(-1 would have the replacement streing end at the current end of the string)
rover("growling","XY",1)   returns "gXYwling"
rover("growling","XY",-2)   returns "growlXYg" 
.EF
=============================================================
.BF
sele()
.(x
sele,strele
.)x 
.FD
sele(sv,index,nc);

used to select part of string variable
index in string (0...length-1), nc  number of chars required
if nc not set (default) the selection is from index to end of string.
newstr = sele(astr,3)
newstr contains from 4th character to end of original string.
newstr = sele(astr,3,3)
newstr contains from 4th character to 6th character of  original string.

if nc is set negative then the selected string is from the 
location of index minus nc to the index.

sele can also be used to cut off an extension. 
newstr = sele("foo.dat",-5)
newstr is original minus the .dat extension.

newstr = sele("foo.dat",-4,4)
newstr is  the extension.

If the index is set  negative (-1) being the last character is the string, 
-2 the penultimate, then nc controls the number of chars selected 
if nc is negative then the selection is towards the beginning of the string, 
e.g. astr= "penultimate"; b=sele(astr,-1,-4) -- b would hold "mate".

.EF
=============================================================
.BF
getsubstr()
.(x
getsubstr
.)x 
.FD
V->getSubStr(index,nc)
obtains sub string of the string variable , indexed at index for number of characters nc.
if is index is negative then indexing is from the end of the string (-1 last character)
if nc is negative then the sub string is the string to the left of the index.
V[k]->substr(3,5) will obtain the 5 characters starting at 4th character (indexing starts at 0)
of the kth 'record' of the string variable.


.EF
=============================================================
.BF
paste()
.(x
paste
.)x 
.FD
V->paste(string,index)
 Pastes in a string into string variable V at index specified.
 if index is negative V is indexed from the end.
.EF 

.EF
=============================================================
.BF
substitute()
.(x
substitute
.)x 
.FD
V->SubStitute(this_str,with_str)
 Substitutes a sub string with another  in the  string variable V 
.EF 

.EF
=============================================================
.BF
cat()
.(x
cat
.)x 
.FD
V->Cat(str1,str2,..)
 Concantenates into string variable V the  string args
 returns length of string variable.
.EF 

.EF
=============================================================
.BF
cpy()
.(x
cpy
.)x 
.FD
V->Cpy(str1)
 Copies into string variable V the  string arg
 returns length of string variable.
.EF 



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//////////////////////////////////// VMF ///////////////////////////////
.HE  
VMF
  Variable member functions (VMF) are functions that operate on the built in typed variables 
(e.g. float,int, short ...). 
 Usually this is a vector operation.
 The syntax is of the form  I->function(arg1, arg2, ...)  or to operate on subset on the vector
 I[subset]->function(arg1,arg2, ..) where the subset can be specfied in any of the range or
 list of element methods
 e.g 
 I[3:7]->cut()
  would cut out elements 3 through 7 of the vector I. 
Typically VMF's operate or modify the operand and return success in terms of true or false.

The svar type is a vector of strings so operations like string compare can be carried out on all
members of the vector and the result returned as a vector
e.g.
rv=S->scmp("and")
would return into a integer vector rv the results of a scmp operation on all elements (strings) of the
svar vector. 

The svar type can be used to set up a lookup table or a hash table with a  variable number of fields.
e.g.
svar ST
nr=ST->table("HASH",num_rows,[num_fields=2]);
makes svar ST into hash table with num_fields(default 2) and initial num_rows.
index=ST->addkeyval(key,ival) 
addkeyval can be used to add a key (string) plus a value (int,float,string).
val= ST->lookup(key)
would be used to return a key's value.

.EF
=============================================================
.BF
table()
.(x
table
.)x 
.FD
svar ST
ST->table("LUT",num_rows,[num_fields=2]);
makes svar ST into a lookup  table with num_fields and initial num_rows.
nr=ST->table("HASH",num_rows,num_fields);
makes svar ST into a hash  table with num_fields and initial num_rows.
returns number of rows in table.
See lookup,addentry,getentry. 

.EF
=============================================================
.BF
lookup()
.(x
lookup
.)x 
.FD
val= ST->lookup(key)
would be used to return a key's value(s) in the table held by svar variable ST.
.EF
=============================================================
.BF
getentry()
.(x
getentry
.)x 
.FD
vals= ST->getentry(keystring)
would be used to return a key's row values in the table 'held' by svar variable ST.
vals= ST->getentry(rowindex)
would be used to return a row's values in the table 'held' by svar variable ST.

.EF
=============================================================
.BF
addentry()
.(x
addentry
.)x 
.FD
vals= ST->addentry(index,val0,val1,...)
Adds a row of vals into the table. If index is -1 adds values to the end.
the number of values added shoud be the same as number of fields in the table.
Can be used to overwrite existing row ( not to add past existing size - except for adding to end)
.EF
=============================================================
.BF
aslpinfo()
.(x
aslpinfo
.)x 
.FD
V.aslpinfo()

the VMF function  V.aslpinfo()
would print out the attributes of an asl variable
S=V.aslpinfo(1)
would return the attributes of an asl variable as a string.
functions  aslxxx should be a NOP for C++ compile.

 pinfo(V)
 S=pinfo(V,1)
 
.EF
=============================================================

.BF
aslcheckinfo()
.(x
aslcheckinfo
.)x 
.FD
V.aslcheckinfo(s)
the VMF function  V.checkinfo(s)
would check for the presence of string s in the attribute description of
asl variable V.
Used for debugging.
 
.EF
=============================================================

.BF
shiftL()
.(x
shiftL
.)x 
.FD
I.shiftL(newval,[nplaces],[vecsize])

An VMF operation to shift elements of an vector one place to the left and replace the last element with
a  new val. Can be repeated nplaces. If vector size is specified as less than actual size the element can 
be inserted at the specified 'end'. (see shiftR) 


.EF
=============================================================
.BF
shiftR()
.(x
shiftR
.)x 
.FD
I->shiftR(newval)
F->shiftR(newval)

An  VMF operation to shift elements of an vector(float,double,int,short,char) one place to the right
and replace the first element with
a  new val. 
 
.EF
=============================================================
.BF
cut()
.(x
cut
.)x 
.FD
I.cut(V)

An  VMF operation to remove selected elements of an vector. 
I->cut(V) the cut function that uses the vector V to indicate which elements of I to 'cut'.

I[3:7]->cut() --- the subscripted range of I is cut from the vector.
The cut operation can be applied to most types,  Float, Double, Int ...
.EF 
=============================================================
.BF
limit()
.(x
limit
.)x 

.FD
A->limit(newrange_lower_limit,newrange_upper_limit)

A vector (or scalars) can be limited to values
at and between the specified limits. 
This is an inplace operation.
(see limitval)
.EF
=============================================================
.BF
limitval()
.(x
limitval
.)x 

.FD
limitVal(V,newrange_lower_limit,newrange_upper_limit)

A vector (or a scalar) can be limited to values
at and between the specified limits. 
returns value or a new vector which has been limited.
(see limit)
.EF
=============================================================
.BF
enumNameFromValue()
.(x
enumNameFromValue
.)x 
.FD
Ename->enumNameFromValue(val)
 Will return the name of the enum entry which has that value.
e.g.
if we declare an enum to hold color values :-

enum colors  {   

              BLACK, 
              WHITE,
              RED,               // rainbow plus
              ORANGE,
              YELLOW,
              GREEN,
              BLUE,
              INDIGO,
              VIOLET,
              SILVER = 47,
}


then 
colors->enumNameFromValue(2)
would return the string RED
colors->enumNameFromIndex(0)
would return the string BLACK
colors->enumValueFromIndex(2)
would return the int val 2
colors->enumIndexFromValue(RED)
would return the int val 2

colors->enumNameFromValue(47)
would return the string SILVER
colors->enumNameFromValue(SILVER)
would return the string SILVER

colors->enumValueFromName("SILVER")
would return the value 47

.EF 


//////////////////////////////// DATABASE OPS ////////////////////////////////////////////










/////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////// NAVIGATION  ////////////////////////////////////////////


.EF
=============================================================
.BF
readBIL()
.(x
readBIL
.)x 
.FD
readBIL
reads a bil extension file from a terrain database  -- DEM



.EF
=============================================================
.BF
getElev()
.(x
getElev
.)x 
.FD
getElev( lat_dd, long_dd)

Once elevation database is loaded  -- return elevation (meters?) closest to entered lat, long (decimal degrees).

.EF
=============================================================
.BF
getTrack()
.(x
getTrack
.)x 
.FD
getTrack( lata_dd, lnga_dd, latb_dd, lngb_dd, [1])
///  get series of  positions lat,lng and next bearing  along great circle track between two positions --- 
///  does so every k km -- default 1.0 km



.EF
=============================================================
.BF
getWGS()
.(x
getWGS
.)x 
.FD
getWGS(track)
/// computes the XYZ values relative to a grid at earth center
/// input track with lat, lng
/// output  X,Y,Z lat,lng, msl
/// needs a loaded elevation database - usually 1 sec resolution



.EF
=============================================================
.BF
trueCourse()
.(x
trueCourse
.)x 
.FD
trueCourse( latA_dd, longA_dd,latB_dd, longB_dd)


returns true course between two positions --- i.e. true heading to fly to reach second position



.EF
=============================================================
.BF
HowFar()
.(x
HowFar
.)x 
.FD
howFar( longA_dd,latA_dd,longB_dd, latB_dd)
returns distance in kilometers between two positions



///////////////////////////////  VECTORS - MATRICES /////////////////////////////////////

.EF
=============================================================
.BF
Matrix()
.(x
Matrix
.)x 
.FD
Operations :-
Transpose
mcycleRow
mcycleCol
mreflect
mrevrows
mrevcols
diagonal
submat

.EF
=============================================================
.BF
mdiag(),diagonal
.(x
mdiag
.)x 

.FD
M=mdiag(V)
take a vector and make it as leading diagonal of a square matrix other elements are zero


.EF
=============================================================
.BF
Transpose()
.(x
Transpose
.)x 

.FD
Transpose(M)
interchanges the rows and columns of 2D matrix,
returns new matrix the original is not altered
e.g.
 A = Transpose(M)

.EF
=============================================================
.BF
cycleRow()
.(x
cycleRow
.)x 

.FD

cycleRow(M,step)
cycles the rows  of 2D matrix,
forward or backward depending on sign and size of step variable
returns new matrix the original is not altered


.EF
=============================================================
.BF
CycleCol()
.(x
CycleCol
.)x 

.FD

CycleCol(M,step)
cycles the columns  of 2D matrix,
forward or backward depending on sign and size of step variable
returns new matrix the original is not altered


.EF
=============================================================
.BF
mxcols,exchangeCols()
.(x
exchangeCols
.)x 
.FD

exchangeCols(M,a,b)
exchanges the columns  of 2D matrix,
returns new matrix the original is not altered

.EF
=============================================================
.BF
mxrows,exchangeRows()
.(x
exchangeRows
.)x 
.FD

exchangeRows(M,a,b)
exchanges the rows  of 2D matrix,
returns new matrix the original is not altered

.EF
=============================================================

.BF
subMat()
.(x
submat
.)x 
.FD

T=submat(M,r,c,R,C)

returns new sub matrix  using r,c,R,C as the row,col indices  into the Matrix.
.EF
=============================================================
.BF
getRow()
.(x
getRow
.)x 
.FD
R=getRow(A,row,[start_i],[finish_i],[step_i])
return a row from a 2D array, optionally a sub-range of the row
this can also be obtained by subscripting the 2D array
 V= M[row][::]
 V= M[row][start_i:finish_i]
 V= M[row][start_i:finish_i:step_i]

.EF
=============================================================
.BF
getCol()
.(x
getCol
.)x 
.FD
R=getCol(A,col,[start_i],[finish_i],[step_i])
return a col from a 2D array, optionally a sub-range of the col
this can also be obtained by subscripting the 2D array
V=M[::][col]

.EF
=============================================================
.BF
flipDim()
.(x
flipDim
.)x 
.FD
flipDim(A,dim)
flips (reverses) multidimension along a dimension
R [3][4]  = 
 0 1 2 3
 4 5 6 7
 8 9 10 11

flipDim(R,0)
 8 9 10 11
 4 5 6 7
 0 1 2 3

flipDim(R,1)
 3 2 1 0
 7 6 5 4
 11 10 9 8


An inplace flipdim will occur on the array variable if the syntax  
R->flipDim(0) 
is used -- the return if this case is 1 for success of the transform or 0 if error.


.EF
=============================================================
.BF
mrowZoom()
.(x
mrowZoom
.)x 
.FD
mrowZoom(M,new_nc, interp_type)

expands matrix along the row to produce a new number of columns, using linear interpolation (optionally cubic spline)
returns new Matrix -- same number of rows but different number of columns.
If interp_type is 1 a cubic spline is used


.EF
=============================================================
.BF
mcolZoom()
.(x
colZoom
.)x 
.FD
mcolZoom(M,new_nr, interp_type)

expands matrix along each column to produce a new number of rows,
using linear interpolation (optionally cubic spline)
returns new Matrix -- same number of columns but different number of rows.
If interp_type is 1 a cubic spline is used


.EF
=============================================================.BF
.BF()
mrevcols
.(x
mrevcols
.)x 
.FD
mrevcols(M)

reverses order of columns - returns new matrix

.EF
=============================================================
.BF
mrevrows()
.(x
mrevrows
.)x 
.FD
mrevrows(M)

reverses order of rows - returns new matrix

.EF
=============================================================
.BF
IDof()
.(x
IDof
.)x 
.FD
IDof(var)
returns internal id of a script variable


//////////////////////////////////// THREADS ///////////////////////////////////////// 
// wrappers around pthreads

.EF
=============================================================
.BF
create_sem()
.(x
createsem
.)x 
.FD
creates a semaphore returns its id

.EF
=============================================================
.BF
getsem_val()
.(x
getsemval
.)x 
.FD
getsemval(s_id)
returns the value of the semaphore 
If value is zero then other thread has the semaphore and will have to wait to get semaphore
(sem_wait)

.EF
=============================================================
.BF
sem_post()
.(x
sempost
.)x 
.FD
sem_post()  increments (unlocks) the semaphore pointed to by sem.  If the semaphoreâs value
       consequently becomes greater than zero,  then  another  process  or  thread  blocked  in  a
       sem_wait(3) call will be woken up and proceed to lock the semaphore.


.EF
=============================================================
.BF
sem_wait()
.(x
semwait
.)x 
.FD
sem_wait() decrements (locks) the semaphore pointed to by sem.  If the semaphore's value is
       greater than zero, then the decrement proceeds, and the function returns, immediately.   If
       the  semaphore  currently  has the value zero, then the call blocks until either it becomes
       possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal
       handler interrupts the call.
.EF
=============================================================
.BF
types()
.(x
types
.)x 
.FD

char  c
short j
int   k
float f
double d
cmplx c
Pan p   p is an arbitary precision number  precision is set via setAP(n)
str s    //  arbitary length string
svar v   // dynamic array of strings - V[0]="alert" ; V[1]="longish string is held here"




The pan type precision is set via the function setAP(n).
Where n is the required number of decimal place for fractional numbers.
.EF

.BF
pan type
.(x
pan
.)x 
.FD
Pan p   p is an arbitary precision number  precision is set via setAP(n)
The pan type precision is set via the function setAP(n).
Where n is the required number of decimal place for fractional numbers.
pan type  uses base 256
e.g
setAP(100)
pan F = exp(1)
pan F would be the constant e with a precision of a 100  places
pan F = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166369

.EF
////////////////////////////////////////////////////////////////////////////////////////
 One line descriptions of main functions

///////////////

.BF
sockets()
.(x
sockets
.)x 
.FD
   The graphic window manager usually communicates with asl clients via shared memory and pipes,
however it can use sockets for communication. The default port is 4779 and the server ip is supplied
on the command line to asl using -S address --- 
e.g.
asl -S 127.0.0.1  scriptname
would launch asl and it attempt to set up socket communication on the local machine (127.0.0.1) using
default port 4779 and run the script indicated on the command line.
.EF
=============================================================
.BF
bell()
.(x
bell
.)x 
.FD
bell(n)
Rings the teletype bell n times.
Using the KDE window manager terminals this option has to be seleted via
the configuration menu (and you can choose the notification sound clip).
.EF
=============================================================
.BF
BubbleSort()
.(x
bubblesort
.)x 
.FD
bubblesort(Vec)
performs bubble sort (low to high) on a vector returns the sorted vector.
Use Vec->reverse() to then obtain results in high to low order.
Should work on all types.
can be used as Vec->BubbleSort() returns 1 if sorted.
.EF
=============================================================
.BF
Zipper()


.(x
zipper
.)x 
.FD
V=zipper(Vec1,Vec2)
zipper, interleaves one vector with another  V3=zipper(V1,V2)
.EF
=============================================================


.BF
zulutime()
.(x
zulutime
.)x 
.FD
zulutime
 returns GMT - hh:mm:ss
.EF
=============================================================
.BF
time()
.(x
time
.)x
returns  hh:mm:ss
.EF
=============================================================
.BF
Variables()
.(x
Variables
.)x 
.FD
S=Variables([values,type])
 returns a list of variables to Svar variable S, default list types and sizes
 or if optional parameter set to 1 - lists values (just first value for vectors)
.EF
=============================================================
.BF
Functions()
.(x
Functions
.)x 
.FD
S=functions()
 returns a list of functions to Svar variable S, with a short description of the function
S= functions() ; S->sort(); <<"%(1,,,\n)$S\n"
would give an alphbetically sorted list.
.EF
=============================================================
.BF
cos()
.(x
cos
.)x 
.FD
cos()
 These functions all directly link to math lib functions of the same name
.EF
===========================================================
.BF
log10()
.(x
log10
.)x 
.FD
log10()
 These functions all directly link to math lib functions of the same name
.EF
============================================================
.BF
log,log2 ~ log base2 Naperian log()
.(x
log,log2
.)x 
.FD
log()
 These functions all directly link to math lib functions of the same name
.EF
============================================================
.BF
rint ~ round to nearest int()
.(x
rint
.)x 
.FD
rint()
 These functions all directly link to math lib functions of the same name
.EF
============================================================
.BF
sin()
.(x
sin
.)x 
.FD
sin()
 These functions all directly link to math lib functions of the same name
.EF
=============================================================
.BF
acos()
.(x
acos
.)x 
.FD
acos()
 link to math lib function of the same name
.EF
=============================================================
.BF
atan()
.(x
atan
.)x 
.FD
atan()
 link to math lib function of the same name
.EF
=============================================================
.BF
tan()
.(x
tan
.)x 
.FD
tan()
 link to math lib function of the same name
.EF
=============================================================
.BF
tanh()
.(x
tanh
.)x 
.FD
tanh()
 link to math lib function of the same name
.EF
=============================================================
.BF
atanh()
.(x
atanh
.)x 
.FD
atanh()
 link to math lib function of the same name
.EF
=============================================================
.BF
asinh()
.(x
asinh
.)x 
.FD
asinh()
 link to math lib function of the same name
.EF
=============================================================
.BF
sinh()
.(x
sinh
.)x 
.FD
sinh()
 link to math lib function of the same name
.EF
=============================================================
.BF
asin()
.(x
asin
.)x 
.FD
asin()
 link to math lib function of the same name
.EF
=============================================================
.BF
acosh()
.(x
acosh
.)x 
.FD
acosh()
 link to math lib function of the same name
.EF
=============================================================
.BF
cosh,acosh,sinh,asinh,tanh,atanh()
.(x
cosh,acosh,sinh,asinh,tanh,atanh
.)x 
.FD
sinh()
 These functions all directly link to math lib functions of the same name.
  cosh (x) = (exp(x) + exp(-x))/ 2.0;

  sinh (x) = (exp(x) - exp(-x))/ 2.0;

  tanh (x) = sinh (x) / cosh (x);

.EF
=============================================================
.BF
cbrt() ~ cube root()
.(x
cbrt
.)x 
.FD
cbrt(X)
 link to math lib function of the same name
.EF
=============================================================
.BF
atol() ~ converts string to long
.(x
atol
.)x 
.FD
atol("number")
 link to math lib function of the same name
.EF
=============================================================
.BF
atou() ~ converts string to ulong
.(x
atou
.)x 
.FD
atou("number")
 link to math lib function of the same name
.EF
=============================================================
.BF
atof() ~ converts string to double
.(x
atof
.)x 
.FD
atof("number")
 link to math lib function of the same name
.EF
=============================================================
.BF
atoi() ~ converts string to int
.(x
atoi
.)x 
.FD
atoi("number")
 link to math lib function of the same name
.EF
=============================================================
.BF
atop() ~ converts string to pan (arbitarily long number)
.(x
atop
.)x 
.FD
 atop("number")
 pan numbers are base 256 can be used for high precision
 (see pan, setap)
.EF
=============================================================
.BF
sizeof
.(x
sizeof
.)x 
.FD
sizeof(var)
 returns number of bytes of internal storage for this type.
  For elements of this type of array.
  Scalar variables are all of Siv type;
  Pan types are strings of char - length is determined by required precision.
.EF
=============================================================
.BF
sivsize()
.(x
sivSize
.)x 
.FD
sivSize()
 returns number of bytes of internal storage of a Siv.
  All scalars are Sivs.
  Arrays have a Siv 'header' which points to the array memory,
  all Siv member functions are used to access and control the
  array memory (with some builtin array overwrite protections).
.EF
=============================================================
.BF
d2r(),~ degrees to radians
.(x
d2r
.)x 
.FD
d2r(degree)
 converts degrees to radians --
 r2d(radian)  is the inverse function - radians to degrees.
.EF
================================================
.BF
r2d(),~ radian to degrees 
.(x
r2d
.)x 
.FD
r2d(rads)
 conver radian to degrees 
.EF
================================================
.BF
pt() ~ periodic table
.(x
pt
.)x 
.FD
pt(val)
  returns periodic table entry if given a number, or if given an element name
  e.g.
  pt(85) returns
  Astatine,At,85,210.000000
 pt("silver") returns
 Silver,Ag,47,107.868202
 ptan("silver") returns 47.
.EF
=============================================================
.BF
fexist()
.(x
fexist
.)x 
.FD
fexist(name)
if file named exists return size - else -1.
.EF
=============================================================
.BF
ftype()
.(x
ftype
.)x 
.FD
ftype(name)
if file named exists returns type returns [dir,regular,symlink,socket,fifo,block] .
else -1.
.EF
===================================================
.BF
fstat() ~ file status
.(x
fstat
.)x 
.FD
fstat(name, att)
if file named exists returns named attribute att::[atime,mtime,adate,uid,...].
e.g.
fstat(name, "uid")  returns effective uid.

.EF
===================================================
.BF
fflush() ~ file flush
.(x
fflush
.)x 
.FD
fflush(FH)
flushes out messages on specified stream (default 1) FH is file handle for that stream.
.EF
===================================================
.BF
gflush ~ graphic instruction flush
.(x
gflush
.)x 
.FD
gflush()
flushes out graphic messages/instructions. They are buffered up normally - this command
send all in current buffer to the graphic manager.
.EF
===================================================
.BF
ofile()
.(x
ofile
.)x 
.FD
ofile(name,perm)
opens/creates file with named permissions ("r,w,a")
e.g. FH=ofile("myfile","w")    opens file for writing returns a file handle FH (-1 if error).
.EF
=============================================================
.BF
ofr()
.(x
ofr
.)x 
.FD
ofr(name)
opens file for reading
e.g. FH=ofr("myfile")    opens file for reading returns a file handle FH (-1 if error).
.EF
=============================================================
.BF
ofw()
.(x
ofw
.)x 
.FD
ofw(name)
opens file for writing
e.g. FH=ofw("myfile")    returns a file handle FH (-1 if error).
.EF
=============================================================
.BF
checkIn()
.(x
checkin
.)x 
.FD
checkIn()
 entry point for a series of tests using checkNumber,checkReal,checkStr, ... finish with CheckOut()
.EF
===================================================
.BF
checkOut()
.(x
checkOut
.)x 
.FD
checkOut()
 exit a series of tests using checkNum,checkFNum,checkStr, ... prints a tally of results
.EF
===================================================
.BF
checkNumber()
.(x
checkNumber,chkN
.)x 
.FD
checkNum(a,b,[operator],[precision])
tests for equality (EQ_) between a and b  at floating precision of 6 places.
Operators allows NEQ_, EQ_,GT_,GTE_,LT_,LTE_   (0,1,2,3,4,5)

e.g
chkN(x,0.479426,EQ_,4);
would test x == 0.479426  to a precision of 4 decimal places.



.EF
==================================================
.BF
checkReal()
.(x
checkReal,chkR
.)x 
.FD
chkR(a,b,[precision])
tests for equality between a and b with optional precesion.
.EF
==================================================
.BF
time2date()
.(x
time2date
.)x 
.FD
time2date(unix_time_secs)
returns date.
.EF
==================================================
.BF
insert()
.(x
insert
.)x 
.FD
list->insert([where],strval,[strval2,strval3,...])
Inserts a list string item into an existing list at 0 (beginning), number (nth item),  -1 (end)
additional string items inserted after first.

.EF
==================================================


.BF
torf()
.(x
torf
.)x 
.FD
torf(val)
returns true or false (val ==0)
.EF
==================================================
.BF
yorn()
.(x
yorn
.)x 
.FD
yorn(val)
returns yes or no (val ==0)
.EF
==================================================
.BF
pr()
.(x
pr
.)x 
.FD
pr(val,[fh])
prints value  -default to stdout  else to stream pointted to with file handle (see ofw).
.EF
==================================================
BF
setkeyval
.(x
setkeyval
.)x 
.FD
setKeyVal(str,str)
setKeyVal(keystr,valstr)  store key value pair (into inbuilt hash table) returns -1 on fail;
.EF
==================================================
BF
getkeyval
.(x
getkeyval
.)x 
.FD
getKeyVal(keystr) returns value from key,value pair from inbuilt hash table.
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================
BF
x??
.(x
x??
.)x 
.FD
x??(n)
 null function
.EF
==================================================

#  Types
BF
svar
.(x
Svar,svar
.)x 
.FD
svar
The svar type is a dynamic array of arbitarily long strings.
svar E[] = { "the first ten elements are:", "H", "He", "Li", "Be" ,"B" ,"C", "N", "O", "F", "Ne"  };

E[3] contains the string Li.

.EF
==================================================
BF
str
.(x
Str,str
.)x 
.FD
svar
The str type can arbitarily long strings.

str S = "a very long string";

S= scat(S," made even longer")

.EF
==================================================
# SpreadSheet Functions
BF
sWo(won,@setrowscols)
.(x
sWo(won,@setrowscols)
.)x 
.FD
sWo(sswo,@setrowscols,Nrows,Ncols)

for the SpreadSheet sswo set the number of rows and cols.
.EF
==================================================
BF
sWo(won,@selectrowscols)
.(x
sWo(won,@selectrowscols)
.)x 
.FD
sWo(sswo,@selectrowscols,startrow,endrow,startcol,endcol,[ONOFF])
for the SpreadSheet sswo select which rows and cols to display.
Can be used to select non-consectutive regions for display.

.EF
==================================================
BF
sWo(won,@setcolsize)
.(x
sWo(won,@setcolsize)
.)x 
.FD
sWo(sswo,@setcolsize,startcol,numofconsecutivecols,unitsize)

allows columns or rows to be set to different unit sizes.
i.e. in multiples of unit size.
also sWo(won,@setrowsize)





==================================================

.BF

.bp
.HE
APPENDIX 2	USER ADDED FUNCTIONS
.sp

The following script shows how a user may add C functions to GASP.

.bp
# user added functions
# see user.c in uat directory
# each user function must be declared in the uat_table
# see uat_table.c
# this script shows how used added C functions can be called via
# a script


# this function could also be called by a menu 
# if its name is in the menu item value field
# e.g. the line in the ed_ops menus
# SPLICE     C_FUNC     splice
# will call the C function splice when the menu item is 'clicked'
# so the line
# USER_1     C_FUNC     user_1
# could be added to an existing menu to access the function user_1
# or a number of new user added routines called be called from a new menu
# browse the menus in the GS/MENUS directory for details

user_1 ()

x = 1
y = 2
z = 3
n = 3


a = user_2(x,y,z,n)

print ( "user_2 ", a)

float X[10]
float Y[10]
float Z[10]

for ( i = 0 ; i < n ; i++) {
X[i] = i
Y[i] = 2 * i
}

user_3(&X[0],&Y[0],&Z[0],n)

for ( i = 0 ; i < n ; i++) 
 print ( X[i]," ", Y[i], " ",Z[i])

.bp


.bp
.HE
INDEX OF FUNCTIONS
.sp
.xp


.HE
APPENDIX 3	DEFINES 
.sp

colors - used in functions to set colors in draw, window operations
BLACK_,
WHITE_,
RED_,
ORANGE_,
YELLOW_,
GREEN_,
BLUE_.

comparison defines - used in Sel,Cmp  vector operations

ALWAYS_
ALL_
GT_
LT_
GTE_
LTE_
EQU
NEQ_
NOP_




.HE
APPENDIX 4	COLORS 
.sp

int
fillHTML_ColorTable ()
{
  //
  // 
  //

  addHTMLColor ("AliceBlue", 240, 248, 255, 0xf0f8ff);
  addHTMLColor ("AntiqueWhite", 250, 235, 215, 0xfaebd7);
  addHTMLColor ("Aqua", 0, 255, 255, 0x00ffff);
  addHTMLColor ("Aquamarine", 127, 255, 212, 0x7fffd4);
  addHTMLColor ("Azure", 240, 255, 255, 0xf0ffff);
  addHTMLColor ("Beige", 245, 245, 220, 0xf5f5dc);
  addHTMLColor ("Bisque", 255, 228, 196, 0xffe4c4);
  addHTMLColor ("Black", 0, 0, 0, 0x000000);
  addHTMLColor ("BlanchedAlmond", 255, 235, 205, 0xffebcd);
  addHTMLColor ("Blue", 0, 0, 255, 0x0000ff);
  addHTMLColor ("BlueViolet", 138, 43, 226, 0x8a2be2);
  addHTMLColor ("Brown", 165, 42, 42, 0xa52a2a);
  addHTMLColor ("Burlywood", 222, 184, 135, 0xdeb887);
  addHTMLColor ("CadetBlue", 95, 158, 160, 0x5f9ea0);
  addHTMLColor ("Chartreuse", 127, 255, 0, 0x7fff00);
  addHTMLColor ("Chocolate", 210, 105, 30, 0xd2691e);
  addHTMLColor ("Coral", 255, 127, 80, 0xff7f50);
  addHTMLColor ("CornflowerBlue", 100, 149, 237, 0x6495ed);
  addHTMLColor ("Cornsilk", 255, 248, 220, 0xfff8dc);
  addHTMLColor ("Cyan", 0, 255, 255, 0x00ffff);
  addHTMLColor ("DarkBlue", 0, 0, 139, 0x00008b);
  addHTMLColor ("DarkCyan", 0, 139, 139, 0x008b8b);
  addHTMLColor ("DarkGoldenrod", 184, 134, 11, 0xb8860b);
  addHTMLColor ("DarkGray", 169, 169, 169, 0xa9a9a9);
  addHTMLColor ("DarkGreen", 0, 100, 0, 0x006400);
  addHTMLColor ("DarkKhaki", 189, 183, 107, 0xbdb76b);
  addHTMLColor ("DarkMagenta", 139, 0, 139, 0x8b008b);
  addHTMLColor ("DarkOliveGreen", 85, 107, 47, 0x556b2f);
  addHTMLColor ("DarkOrange", 255, 140, 0, 0xff8c00);
  addHTMLColor ("DarkOrchid", 153, 50, 204, 0x9932cc);
  addHTMLColor ("DarkRed", 139, 0, 0, 0x8b0000);
  addHTMLColor ("DarkSalmon", 233, 150, 122, 0xe9967a);
  addHTMLColor ("DarkSeaGreen", 143, 188, 143, 0x8fbc8f);
  addHTMLColor ("DarkSlateBlue", 72, 61, 139, 0x483d8b);
  addHTMLColor ("DarkSlateGray", 47, 79, 79, 0x2f4f4f);
  addHTMLColor ("DarkTurquoise", 0, 206, 209, 0x00ced1);
  addHTMLColor ("DarkViolet", 148, 0, 211, 0x9400d3);
  addHTMLColor ("DeepPink", 255, 20, 147, 0xff1493);
  addHTMLColor ("DeepSkyBlue", 0, 191, 255, 0x00bfff);
  addHTMLColor ("DimGray", 105, 105, 105, 0x696969);
  addHTMLColor ("DodgerBlue", 30, 144, 255, 0x1e90ff);
  addHTMLColor ("Firebrick", 178, 34, 34, 0xb22222);
  addHTMLColor ("FloralWhite", 255, 250, 240, 0xfffaf0);
  addHTMLColor ("ForestGreen", 34, 139, 34, 0x228b22);
  addHTMLColor ("Fuschia", 255, 0, 255, 0xff00ff);
  addHTMLColor ("Gainsboro", 220, 220, 220, 0xdcdcdc);
  addHTMLColor ("GhostWhite", 248, 248, 255, 0xf8f8ff);
  addHTMLColor ("Golden", 255, 215, 0, 0xffd700);
  addHTMLColor ("Goldenrod", 218, 165, 32, 0xdaa520);
  addHTMLColor ("GoldenrodYellow", 250, 250, 210, 0xfafad2);
  addHTMLColor ("Gray", 128, 128, 128, 0x808080);
  addHTMLColor ("Green", 0, 128, 0, 0x008000);
  addHTMLColor ("GreenYellow", 173, 255, 47, 0xadff2f);
  addHTMLColor ("Honeydew", 240, 255, 240, 0xf0fff0);
  addHTMLColor ("HotPink", 255, 105, 180, 0xff69b4);
  addHTMLColor ("Indigo", 75, 0, 130, 0x4b0082);
  addHTMLColor ("IndianRed", 205, 92, 92, 0xcd5c5c);
  addHTMLColor ("Ivory", 255, 255, 240, 0xfffff0);
  addHTMLColor ("Khaki", 240, 230, 140, 0xf0e68c);
  addHTMLColor ("Lavender", 230, 230, 250, 0xe6e6fa);
  addHTMLColor ("LavenderBlush", 255, 240, 245, 0xfff0f5);
  addHTMLColor ("LawnGreen", 124, 252, 0, 0x7cfc00);
  addHTMLColor ("LemonChiffon", 255, 250, 205, 0xfffacd);
  addHTMLColor ("LightBlue", 173, 216, 230, 0xadd8e6);
  addHTMLColor ("LightCoral", 240, 128, 128, 0xf08080);
  addHTMLColor ("LightCyan", 224, 255, 255, 0xe0ffff);
  addHTMLColor ("LightGoldenrod", 238, 221, 130, 0xeedd82);
  addHTMLColor ("Lilac", 200, 162, 200, 0xc8a2c8);
  addHTMLColor ("LightGray", 211, 211, 211, 0xd3d3d3);
  addHTMLColor ("LightGreen", 144, 238, 144, 0x90ee90);
  addHTMLColor ("LightPink", 255, 182, 193, 0xffb6c1);
  addHTMLColor ("LightSalmon", 255, 160, 122, 0xffa07a);
  addHTMLColor ("LightSeaGreen", 32, 178, 170, 0x20b2aa);
  addHTMLColor ("LightSkyBlue", 135, 206, 250, 0x87cefa);
  addHTMLColor ("LightSlateBlue", 132, 112, 255, 0x8470ff);
  addHTMLColor ("LightSlateGray", 119, 136, 153, 0x778899);
  addHTMLColor ("LightSteelBlue", 176, 196, 222, 0xb0c4de);
  addHTMLColor ("LightYellow", 255, 255, 224, 0xffffe0);
  addHTMLColor ("Lime", 0, 255, 0, 0x00ff00);
  addHTMLColor ("LimeGreen", 50, 205, 50, 0x32cd32);
  addHTMLColor ("Linen", 250, 240, 230, 0xfaf0e6);
  addHTMLColor ("Magenta", 255, 0, 255, 0xff00ff);
  addHTMLColor ("Maroon", 128, 0, 0, 0x800000);
  addHTMLColor ("MedAquamarine", 102, 205, 170, 0x66cdaa);
  addHTMLColor ("MediumBlue", 0, 0, 205, 0x0000cd);
  addHTMLColor ("MediumOrchid", 186, 85, 211, 0xba55d3);
  addHTMLColor ("MediumPurple", 147, 112, 219, 0x9370db);
  addHTMLColor ("MediumSeaGreen", 60, 179, 113, 0x3cb371);
  addHTMLColor ("MedSlateBlue", 123, 104, 238, 0x7b68ee);
  addHTMLColor ("MedSpringGreen", 0, 250, 154, 0x00fa9a);
  addHTMLColor ("MedTurquoise", 72, 209, 204, 0x48d1cc);
  addHTMLColor ("MedViolet-Red", 199, 21, 133, 0xc71585);
  addHTMLColor ("MidnightBlue", 25, 25, 112, 0x191970);
  addHTMLColor ("MintCream", 245, 255, 250, 0xf5fffa);
  addHTMLColor ("MistyRose", 255, 228, 225, 0xffe4e1);
  addHTMLColor ("Moccasin", 255, 228, 181, 0xffe4b5);
  addHTMLColor ("NavajoWhite", 255, 222, 173, 0xffdead);
  addHTMLColor ("Navy", 0, 0, 128, 0x000080);
  addHTMLColor ("OldLace", 253, 245, 230, 0xfdf5e6);
  addHTMLColor ("Olive", 128, 128, 0, 0x808000);
  addHTMLColor ("OliveDrab", 107, 142, 35, 0x6b8e23);
  addHTMLColor ("Orange", 255, 165, 0, 0xffa500);
  addHTMLColor ("OrangeRed", 255, 69, 0, 0xff4500);
  addHTMLColor ("Orchid", 218, 112, 214, 0xda70d6);
  addHTMLColor ("PaleGoldenrod", 238, 232, 170, 0xeee8aa);
  addHTMLColor ("PaleGreen", 152, 251, 152, 0x98fb98);
  addHTMLColor ("PaleTurquoise", 175, 238, 238, 0xafeeee);
  addHTMLColor ("PaleVioletRed", 219, 112, 147, 0xdb7093);
  addHTMLColor ("PapayaWhip", 255, 239, 213, 0xffefd5);
  addHTMLColor ("PeachPuff", 255, 218, 185, 0xffdab9);
  addHTMLColor ("Peru", 205, 133, 63, 0xcd853f);
  addHTMLColor ("Pink", 255, 192, 203, 0xffc0cb);
  addHTMLColor ("Plum", 221, 160, 221, 0xdda0dd);
  addHTMLColor ("PowderBlue", 176, 224, 230, 0xb0e0e6);
  addHTMLColor ("Purple", 128, 0, 128, 0x800080);
  addHTMLColor ("Red", 255, 0, 0, 0xff0000);
  addHTMLColor ("RosyBrown", 188, 143, 143, 0xbc8f8f);
  addHTMLColor ("RoyalBlue", 65, 105, 225, 0x4169e1);
  addHTMLColor ("SaddleBrown", 139, 69, 19, 0x8b4513);
  addHTMLColor ("Salmon", 250, 128, 114, 0xfa8072);
  addHTMLColor ("SandyBrown", 244, 164, 96, 0xf4a460);
  addHTMLColor ("SeaGreen", 46, 139, 87, 0x2e8b57);
  addHTMLColor ("Seashell", 255, 245, 238, 0xfff5ee);
  addHTMLColor ("Sienna", 160, 82, 45, 0xa0522d);
  addHTMLColor ("Silvery", 192, 192, 192, 0xc0c0c0);
  addHTMLColor ("SkyBlue", 135, 206, 235, 0x87ceeb);
  addHTMLColor ("SlateBlue", 106, 90, 205, 0x6a5acd);
  addHTMLColor ("SlateGray", 112, 128, 144, 0x708090);
  addHTMLColor ("Snow", 255, 250, 250, 0xfffafa);
  addHTMLColor ("SpringGreen", 0, 255, 127, 0x00ff7f);
  addHTMLColor ("SteelBlue", 70, 130, 180, 0x4682b4);
  addHTMLColor ("Tan", 210, 180, 140, 0xd2b48c);
  addHTMLColor ("Teal", 0, 128, 128, 0x008080);
  addHTMLColor ("Thistle", 216, 191, 216, 0xd8bfd8);
  addHTMLColor ("Tomato", 255, 99, 71, 0xff6347);
  addHTMLColor ("Turquoise", 64, 224, 208, 0x40e0d0);
  addHTMLColor ("Violet", 238, 130, 238, 0xee82ee);
  addHTMLColor ("VioletRed", 208, 32, 144, 0xd02090);
  addHTMLColor ("Wheat", 245, 222, 179, 0xf5deb3);
  addHTMLColor ("White", 255, 255, 255, 0xffffff);
  addHTMLColor ("WhiteSmoke", 245, 245, 245, 0xf5f5f5);
  addHTMLColor ("Yellow", 255, 255, 0, 0xffff00);
  addHTMLColor ("Grey", 128, 128, 128, 0x808080);
  int nc = addHTMLColor ("YellowGreen", 154, 205, 50, 0x9acd32);

//=============== END ASLMAN.txt =================//
\"/////////////////////////////////<**|**>/////////////////////////////////////
\" @doc   ASLMAN
\" @cdate  1/1/90
\" @date  5/31/2020
\" @version 2.2
\" @Copyright  RootMeanSquare  1990,2020 --> 
\"///////////////////////////////////<v_&_v>/////////////////////////////////
